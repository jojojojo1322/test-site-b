import type { DomainWithMetadata, ScaleType } from '../../interfaces/scaleTypes';
export declare const AGGREGATION_INDEX_X_MIN = 0;
export declare const AGGREGATION_INDEX_X_MAX = 1;
export declare const AGGREGATION_INDEX_Y_MIN = 2;
export declare const AGGREGATION_INDEX_Y_MAX = 3;
export declare const AGGREGATION_SPAN = 4;
export declare const AGGREGATION_THRESHOLD = 1000;
export declare const AGGREGATION_MAX_POINTS = 10;
export declare const AGGREGATION_MIN_RANGE = 64;
export declare const AGGREGATION_INDEX_UNSET = 4294967295;
export declare function aggregationRangeFittingPoints(xValues: any[], d0: number, d1: number, opts?: {
    smallestKeyInterval?: number;
    xNeedsValueOf?: boolean;
}): number;
export declare function aggregationDomain(scale: ScaleType, domainInput: DomainWithMetadata<any>): [number, number];
export declare function aggregationXRatioForDatumIndex(datumIndex: any, domainCount: number): number;
export declare function aggregationXRatioForXValue(xValue: any, d0: number, d1: number, xNeedsValueOf: boolean): number;
export declare function aggregationIndexForXRatio(xRatio: number, maxRange: number): number;
export declare function aggregationBucketForDatum(xValues: any[], d0: number, d1: number, maxRange: number, datumIndex: number, { xNeedsValueOf, xValuesLength }?: {
    xNeedsValueOf?: boolean;
    xValuesLength?: number;
}): number;
export declare function aggregationDatumMatchesIndex(indexData: Uint32Array, aggIndex: number, datumIndex: number, offsets: number[]): boolean;
export declare function createAggregationIndices(xValues: any[], yMaxValues: any[], yMinValues: any[], d0: number, d1: number, maxRange: number, { positive, split, xNeedsValueOf, yNeedsValueOf, reuseIndexData, reuseValueData, reuseNegativeIndexData, reuseNegativeValueData, }?: {
    positive?: boolean;
    split?: boolean;
    xNeedsValueOf?: boolean;
    yNeedsValueOf?: boolean;
    reuseIndexData?: Uint32Array;
    reuseValueData?: Float64Array;
    reuseNegativeIndexData?: Uint32Array;
    reuseNegativeValueData?: Float64Array;
}): {
    indexData: Uint32Array;
    valueData: Float64Array;
    negativeIndexData?: Uint32Array;
    negativeValueData?: Float64Array;
};
export declare function compactAggregationIndices(indexData: Uint32Array, valueData: Float64Array, maxRange: number, { inPlace, midpointData, reuseIndexData, reuseValueData, }?: {
    inPlace?: boolean;
    midpointData?: Uint32Array;
    reuseIndexData?: Uint32Array;
    reuseValueData?: Float64Array;
}): {
    maxRange: number;
    indexData: Uint32Array;
    valueData: Float64Array;
    midpointData: Uint32Array;
};
export interface AggregationLevelState {
    maxRange: number;
    indexData: Uint32Array;
    valueData: Float64Array;
    midpointData?: Uint32Array;
}
/**
 * Computes midpoint indices from aggregation index data.
 * For each bucket, calculates the midpoint between min and max X indices.
 *
 * This generic helper consolidates the `getMidpoints()` functions from
 * rangeBarAggregation and ohlcAggregation, and `getIndices()` from barAggregation.
 *
 * @param maxRange - Number of aggregation buckets
 * @param indexData - Aggregation index data (TypedArray)
 * @param reuseMidpointData - Optional pre-allocated array to reuse (must be correct size)
 * @param xMinOffset - Offset for the X min index within each bucket
 * @param xMaxOffset - Offset for the X max index within each bucket
 * @param invalidSentinel - Sentinel value indicating invalid/empty buckets (-1 or AGGREGATION_INDEX_UNSET)
 * @returns Array of midpoint indices representing each bucket
 */
export declare function getMidpointsForIndices(maxRange: number, indexData: Uint32Array, reuseMidpointData?: Uint32Array, xMinOffset?: number, xMaxOffset?: number, invalidSentinel?: number): Uint32Array;
export declare function collectAggregationLevels<T>(state: AggregationLevelState, { collectLevel, shouldContinue, minRange, compactInPlace, }: {
    collectLevel: (state: AggregationLevelState) => T;
    shouldContinue: (level: T, state: AggregationLevelState) => boolean;
    minRange?: number;
    compactInPlace?: boolean;
}): T[];
/**
 * Filter interface for extremes-based aggregation (OHLC, RangeBar).
 * Tracks indices that represent extrema values within each aggregation bucket.
 */
export interface ExtremesAggregationFilter {
    indexData: Uint32Array;
    valueData: Float64Array;
    maxRange: number;
    midpointIndices: Uint32Array;
}
/**
 * Result type for partial extremes aggregation with deferred computation.
 */
export interface ExtremesPartialAggregationResult {
    /** Levels computed immediately (includes the target level) */
    immediate: ExtremesAggregationFilter[];
    /** Function to compute remaining coarser levels, or undefined if all levels computed */
    computeRemaining?: () => ExtremesAggregationFilter[];
}
/**
 * Computes multi-level aggregation filters for extremes-based chart data (OHLC, RangeBar).
 *
 * Creates progressively coarser aggregation levels for efficient rendering
 * of large datasets. Tracks extrema values (min/max for both X and Y) as indices
 * within each aggregation bucket.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values (typically time/date)
 * @param highValues - High/max Y values for each data point
 * @param lowValues - Low/min Y values for each data point
 * @param options - Configuration options
 * @returns Array of aggregation filters from coarse to fine resolution, or undefined if below threshold
 */
export declare function computeExtremesAggregation(domain: [number, number], xValues: any[], highValues: any[], lowValues: any[], options: {
    smallestKeyInterval: number | undefined;
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    existingFilters?: ExtremesAggregationFilter[];
}): ExtremesAggregationFilter[] | undefined;
/**
 * Computes extremes aggregation with deferred full recomputation.
 *
 * For real-time data updates, this computes only the single aggregation level
 * needed for the current zoom, deferring a full recomputation of all levels
 * to idle time.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param highValues - High/max Y values
 * @param lowValues - Low/min Y values
 * @param options - Configuration options including targetRange
 * @returns Partial result with the immediate level and a function to compute all levels
 */
export declare function computeExtremesAggregationPartial(domain: [number, number], xValues: any[], highValues: any[], lowValues: any[], options: {
    smallestKeyInterval: number | undefined;
    targetRange: number;
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    existingFilters?: ExtremesAggregationFilter[];
}): ExtremesPartialAggregationResult | undefined;
