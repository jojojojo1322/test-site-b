import type { GridOptions, NestedDataGetter, RefreshModelParams } from 'ag-grid-community';
import { BeanStub, RowNode } from 'ag-grid-community';
import type { IRowGroupingStrategy } from '../rowHierarchy/rowHierarchyUtils';
export declare class TreeGroupStrategy<TData = any> extends BeanStub implements IRowGroupingStrategy<TData> {
    nestedDataGetter: NestedDataGetter<TData> | null;
    private parentIdGetter;
    nonLeafsById: Map<string, RowNode<TData>> | null;
    private nodesToUnselect;
    private fullReload;
    postConstruct(): void;
    onPropChange(changedProps: ReadonlySet<keyof GridOptions<any>> | null): void;
    destroy(): void;
    reset(): void;
    clearNonLeafs(): void;
    getNonLeaf(id: string): RowNode<TData> | undefined;
    loadGroupData(node: RowNode<TData>): Record<string, any> | null;
    execute(rootNode: RowNode<TData>, params: RefreshModelParams<TData>): boolean;
    private flagUpdatedNodes;
    private initRowsParents;
    private initRowParent;
    private destroyFillerRows;
    private initRowsChildrenSize;
    private initRowChildrenSize;
    private preprocessRows;
    private traverseRoot;
    /**
     * After all the rows are initialized and treeParent is set and childrenAfterGroup is filled,
     * we traverse the tree to finalize it
     * @returns the number of leaf nodes processed, which is used to detect cycles in the tree, and a flag set if leaf children were changed.
     */
    private traverse;
    /** Handle cycles in a tree. Is not optimal for performance but this is an edge case that shouldn't happen as is a warning. */
    private handleCycles;
    /** Load the tree structure for nested groups, aka children property */
    private loadNested;
    /** Load the tree structure for self-referencing data, aka parentId field */
    private loadSelfRef;
    private loadFlattened;
    /** Load the tree structure for data paths, aka getDataPath callback */
    private loadDataPath;
    private loadExistingDataPath;
    private duplicatedPath;
    private buildFromPaths;
    /** Collect separators positions, fast string split without allocations */
    private splitPathKey;
    /** Walk forward from startLevel to segmentsLen creating missing filler nodes and return the final parent. */
    private buildMissingFillers;
    private processDuplicatePaths;
    private getOrCreateFiller;
    /**
     * Build the base filler ID up to the given 'level' and include the final level separator prefix.
     * Caller should append only the 'fillerKey' after this base.
     * Result format:
     * - With no prefix and level === 0: _ROW_ID_PREFIX_ROW_GROUP + '0-'
     * - With no prefix and level > 0: _ROW_ID_PREFIX_ROW_GROUP + '0-key0-1-key1-...-(level-1)-key(level-1)-level-'
     * - With prefix present: prefixId + '-level-'
     */
    private makeFillerIdBase;
    private deselectHiddenNodes;
    private hideRow;
    onShowRowGroupColsSetChanged(): void;
}
