import type { AgColumn, BeanCollection, FormulaFunctionParams, IFormulaService, NamedBean, RowNode, _ColumnCollections } from 'ag-grid-community';
import { BeanStub } from 'ag-grid-community';
import type { FormulaNode } from './ast/utils';
import { FormulaError } from './ast/utils';
/**
 * Cell Formula Cache
 * Caches the parsed AST until the formula changes, and the last computed value/error.
 */
export declare class CellFormula {
    readonly rowNode: RowNode;
    readonly column: AgColumn;
    formulaString: string;
    private readonly beans;
    error: FormulaError | null;
    ast: FormulaNode | null;
    astStale: boolean;
    private _value;
    private _valueStale;
    constructor(rowNode: RowNode, column: AgColumn, formulaString: string, beans: BeanCollection);
    setFormulaString(next: string): void;
    /** Cache write: store a fresh computed value (and clear previous error). */
    setComputedValue(v: unknown): void;
    /** Cache write: store an error (value considered stale). */
    setError(e: FormulaError): void;
    isValueReady(): boolean;
    /**
     * Return the error type or the value
     */
    getValue(): unknown;
    getError(): FormulaError | null;
    /** Returns the AST for the formula and recomputes if stale */
    getAst(): FormulaNode | null;
}
export declare class FormulaService extends BeanStub implements IFormulaService, NamedBean {
    readonly beanName: "formula";
    /** Cache: row -> (column -> CellFormula) */
    private cachedResult;
    /** Map "A", "B", ..., "AA" -> actual AgColumn */
    private colRefMap;
    /** Built-in operations (extendable via gridOptions.formulaFuncs). */
    private supportedOperations;
    active: boolean;
    setFormulasActive(cols: _ColumnCollections): void;
    private checkForIncompatibleServices;
    postConstruct(): void;
    updateFormulaByOffset(params: {
        value: string;
        rowDelta?: number;
        columnDelta?: number;
        useRefFormat?: boolean;
    }): string;
    private setupFunctions;
    private setupColRefMap;
    /** Lookup a column by A1-style reference label, e.g. "A", "AB". */
    getColByRef(ref: string): AgColumn | null;
    /** Find the A1-style label for a given column (reverse lookup). */
    getColRef(col: AgColumn): string | null;
    /** Clear all cached results and re-render cells. */
    refreshFormulas(refreshCells: boolean): void;
    /**
     * Is a value a formula string (starts with '=')
     **/
    isFormula(value: unknown): value is `=${string}`;
    /**
     * Normalise a formula by parsing and serializing it (REF(COLUMN(), ROW()) format).
     * @returns null if the formula is invalid.
     */
    normaliseFormula(value: string, shorthand?: boolean): string | null;
    /** If the cell has been evaluated and errored, return its last error (else null). */
    getFormulaError(column: AgColumn, node: RowNode): FormulaError | null;
    /** Get a registered function by name (used by the evaluator). */
    getFunction(name: string): ((params: FormulaFunctionParams) => unknown) | undefined;
    /** Ensure a CellFormula exists for (row,col) if it's a formula cell; returns null for non-formula. */
    private ensureCellFormula;
    private getFormulaFromDataSource;
    /** Fetch a non-formula value from the grid without triggering nested formula calc. */
    private fetchRawValue;
    /**
     * The context needs to be stored at the class level, as if a valueGetter trys to resolve another formula cell
     * using api.getCellValue, cyclic dependency issues may occur.
     */
    private activeCtx;
    private getVisitorContext;
    private makeFormulaFrame;
    /**
     * Evaluate a single cell's formula **iteratively** (no recursion to avoid large stack traces),
     * caching dependency results into their own CellFormula entries.
     *
     * Returns the computed value, or a '#...' string on error.
     */
    resolveValue(column: AgColumn, node: RowNode): unknown;
}
