import { type AgRangeBarSeriesOptions, type AgRangeBarSeriesStyle, type TextOrSegments, _ModuleSupport } from 'ag-charts-community';
import { ChartAxisDirection, type DomainWithMetadata, type Point } from 'ag-charts-core';
import { RangeBarProperties } from './rangeBarProperties';
interface RangeBarNodeLabelDatum extends Readonly<Point> {
    datumIndex: number;
    text: TextOrSegments;
    textAlign: CanvasTextAlign;
    textBaseline: CanvasTextBaseline;
    datum: any;
    itemType: 'high' | 'low';
    series: _ModuleSupport.CartesianSeriesNodeDatum['series'];
}
type RangeBarItemId = `${string}-${string}`;
interface RangeBarNodeDatum extends Omit<_ModuleSupport.CartesianSeriesNodeDatum, 'yKey' | 'yValue'>, Readonly<Point> {
    readonly index: number;
    readonly itemId: RangeBarItemId;
    readonly yLowKey: string;
    readonly yHighKey: string;
    readonly yLowValue: number;
    readonly yHighValue: number;
    readonly width: number;
    readonly height: number;
    readonly labels: RangeBarNodeLabelDatum[];
    readonly crisp: boolean;
    readonly clipBBox?: _ModuleSupport.BBox;
    readonly opacity?: number;
    style?: Required<AgRangeBarSeriesStyle>;
}
type RangeBarAnimationData = _ModuleSupport.AbstractBarSeriesAnimationData<_ModuleSupport.Rect, RangeBarNodeDatum, RangeBarNodeLabelDatum>;
declare class RangeBarSeriesNodeEvent<TEvent extends string = _ModuleSupport.SeriesNodeEventTypes> extends _ModuleSupport.SeriesNodeEvent<RangeBarNodeDatum, TEvent> {
    readonly xKey?: string;
    readonly yLowKey?: string;
    readonly yHighKey?: string;
    constructor(type: TEvent, nativeEvent: Event, datum: RangeBarNodeDatum, series: RangeBarSeries);
}
interface RangeBarSeriesNodeDataContext extends _ModuleSupport.AbstractBarSeriesNodeDataContext<RangeBarNodeDatum, RangeBarNodeLabelDatum> {
    itemId: RangeBarItemId;
    styles: _ModuleSupport.SeriesNodeStyleContext<AgRangeBarSeriesStyle>;
}
export declare class RangeBarSeries extends _ModuleSupport.AbstractBarSeries<_ModuleSupport.Rect<RangeBarNodeDatum>, AgRangeBarSeriesOptions, RangeBarProperties, RangeBarNodeDatum, RangeBarNodeLabelDatum, RangeBarSeriesNodeDataContext> {
    static readonly className = "RangeBarSeries";
    static readonly type: "range-bar";
    properties: RangeBarProperties;
    private readonly aggregationManager;
    protected readonly NodeEvent: typeof RangeBarSeriesNodeEvent;
    constructor(moduleCtx: _ModuleSupport.ModuleContext);
    processData(dataController: _ModuleSupport.DataController): Promise<void>;
    private aggregateData;
    private estimateTargetRange;
    getSeriesDomain(direction: ChartAxisDirection): DomainWithMetadata<any>;
    getSeriesRange(_direction: ChartAxisDirection, visibleRange: [any, any]): any[];
    /**
     * Creates shared context for node datum creation/update operations.
     * This context is instantiated once and reused across all datum operations
     * to minimize memory allocations. Only caches values that are expensive to
     * compute - cheap property lookups use `this` directly.
     */
    private createNodeDatumContext;
    /**
     * Validates and prepares state needed for node creation/update.
     * Returns undefined if datum should be skipped.
     */
    private prepareNodeDatumState;
    /**
     * Creates a minimal skeleton node - actual values set by updateNodeDatum.
     */
    private createSkeletonNodeDatum;
    /**
     * Creates a new node: skeleton + update.
     */
    private createNodeDatum;
    /**
     * Updates node properties in-place.
     * Shared by both create (skeleton + update) and incremental update paths.
     */
    private updateNodeDatum;
    /**
     * Handles node creation/update - reuses existing nodes when possible for incremental updates.
     * This method decides whether to update existing nodes in-place or create new ones.
     */
    private upsertNodeDatum;
    /**
     * Creates node data using aggregation filters for large datasets.
     */
    private createNodeDataWithAggregation;
    /**
     * Creates node data for simple (ungrouped) data processing.
     */
    private createNodeDataSimple;
    /**
     * Creates node data for grouped data processing.
     */
    private createNodeDataGrouped;
    createNodeData(): RangeBarSeriesNodeDataContext | undefined;
    /**
     * Updates existing label data in place or creates new labels if needed.
     * This avoids array allocations during incremental updates.
     * Uses positional params (no destructuring) for performance in hot path.
     */
    private updateLabelData;
    protected nodeFactory(): _ModuleSupport.Rect<any>;
    private getStyle;
    private makeStylerParams;
    protected updateDatumSelection(opts: {
        nodeData: RangeBarNodeDatum[];
        datumSelection: _ModuleSupport.Selection<_ModuleSupport.Rect, RangeBarNodeDatum>;
    }): _ModuleSupport.Selection<_ModuleSupport.Rect<any>, RangeBarNodeDatum>;
    private getItemStyle;
    private makeItemStylerParams;
    protected updateDatumStyles(opts: {
        datumSelection: _ModuleSupport.Selection<_ModuleSupport.Rect, RangeBarNodeDatum>;
        isHighlight: boolean;
    }): void;
    protected updateDatumNodes({ datumSelection, isHighlight, }: {
        datumSelection: _ModuleSupport.Selection<_ModuleSupport.Rect, RangeBarNodeDatum>;
        isHighlight: boolean;
    }): void;
    protected updateLabelSelection(opts: {
        labelData: RangeBarNodeLabelDatum[];
        labelSelection: RangeBarAnimationData['labelSelection'];
    }): _ModuleSupport.Selection<_ModuleSupport.Text<any>, RangeBarNodeLabelDatum>;
    protected updateLabelNodes(opts: {
        labelSelection: _ModuleSupport.Selection<_ModuleSupport.Text, RangeBarNodeLabelDatum>;
        isHighlight?: boolean;
    }): void;
    protected getHighlightLabelData(labelData: RangeBarNodeLabelDatum[], highlightedItem: RangeBarNodeDatum): RangeBarNodeLabelDatum[] | undefined;
    getTooltipContent(datumIndex: number): _ModuleSupport.TooltipContent | undefined;
    private legendItemSymbol;
    getLegendData(legendType: _ModuleSupport.ChartLegendType): _ModuleSupport.CategoryLegendDatum[];
    protected resetDatumAnimation(data: RangeBarAnimationData): void;
    animateEmptyUpdateReady({ datumSelection, labelSelection }: RangeBarAnimationData): void;
    animateWaitingUpdateReady(data: RangeBarAnimationData): void;
    private getDatumId;
    protected isLabelEnabled(): boolean;
    protected computeFocusBounds({ datumIndex }: _ModuleSupport.PickFocusInputs): _ModuleSupport.BBox | undefined;
    protected hasItemStylers(): boolean;
}
export {};
