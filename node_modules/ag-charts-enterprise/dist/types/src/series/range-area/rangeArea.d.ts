import { type AgRangeAreaSeriesOptions, type AgSeriesMarkerStyle, _ModuleSupport } from 'ag-charts-community';
import { ChartAxisDirection, type ConstructorReturnType, type DomainWithMetadata } from 'ag-charts-core';
import { type RangeAreaMarkerDatum, RangeAreaProperties } from './rangeAreaProperties';
import { type RangeAreaContext, type RangeAreaLabelDatum } from './rangeAreaUtil';
declare class RangeAreaSeriesNodeEvent<TEvent extends string = _ModuleSupport.SeriesNodeEventTypes> extends _ModuleSupport.SeriesNodeEvent<RangeAreaMarkerDatum, TEvent> {
    readonly xKey?: string;
    readonly yLowKey?: string;
    readonly yHighKey?: string;
    constructor(type: TEvent, nativeEvent: Event, datum: RangeAreaMarkerDatum, series: RangeAreaSeries);
}
declare const BaseSeries: (abstract new ({ pathsPerSeries, pathsZIndexSubOrderOffset, datumSelectionGarbageCollection, animationAlwaysUpdateSelections, segmentedDataNodes, animationResetFns, propertyKeys, propertyNames, ...otherOpts }: Partial<{
    pathsPerSeries: string[];
    pathsZIndexSubOrderOffset: number[];
    propertyKeys: import("packages/ag-charts-community/dist/types/src/chart/series/series").SeriesDirectionKeysMapping<RangeAreaProperties>;
    propertyNames: import("packages/ag-charts-community/dist/types/src/chart/series/series").SeriesDirectionKeysMapping<RangeAreaProperties>;
    datumSelectionGarbageCollection: boolean;
    animationAlwaysUpdateSelections: boolean;
    segmentedDataNodes: boolean;
    animationResetFns?: {
        path?: ((path: _ModuleSupport.Path<RangeAreaMarkerDatum>) => Partial<_ModuleSupport.Path<RangeAreaMarkerDatum>>) | undefined;
        datum?: ((node: _ModuleSupport.Marker, datum: RangeAreaMarkerDatum) => _ModuleSupport.AnimationValue & Partial<_ModuleSupport.Marker>) | undefined;
        label?: ((node: _ModuleSupport.Text<any>, datum: RangeAreaLabelDatum) => _ModuleSupport.AnimationValue & Partial<_ModuleSupport.Text<any>>) | undefined;
    } | undefined;
}> & Pick<{
    pathsPerSeries: string[];
    pathsZIndexSubOrderOffset: number[];
    propertyKeys: import("packages/ag-charts-community/dist/types/src/chart/series/series").SeriesDirectionKeysMapping<RangeAreaProperties>;
    propertyNames: import("packages/ag-charts-community/dist/types/src/chart/series/series").SeriesDirectionKeysMapping<RangeAreaProperties>;
    datumSelectionGarbageCollection: boolean;
    animationAlwaysUpdateSelections: boolean;
    segmentedDataNodes: boolean;
    animationResetFns?: {
        path?: ((path: _ModuleSupport.Path<RangeAreaMarkerDatum>) => Partial<_ModuleSupport.Path<RangeAreaMarkerDatum>>) | undefined;
        datum?: ((node: _ModuleSupport.Marker, datum: RangeAreaMarkerDatum) => _ModuleSupport.AnimationValue & Partial<_ModuleSupport.Marker>) | undefined;
        label?: ((node: _ModuleSupport.Text<any>, datum: RangeAreaLabelDatum) => _ModuleSupport.AnimationValue & Partial<_ModuleSupport.Text<any>>) | undefined;
    } | undefined;
}, "propertyKeys" | "propertyNames"> & import("packages/ag-charts-community/dist/types/src/chart/series/series").SeriesConstructorOpts<RangeAreaProperties> & {
    categoryKey: string | undefined;
    clipFocusBox?: boolean | undefined;
}) => _ModuleSupport.CartesianSeries<_ModuleSupport.Marker, AgRangeAreaSeriesOptions<any, unknown>, RangeAreaProperties, RangeAreaMarkerDatum, RangeAreaLabelDatum, RangeAreaContext, never>) & {
    readonly className: string;
};
type IBaseSeries = ConstructorReturnType<typeof BaseSeries>;
type GetMarkerStyleArg<I extends number> = Parameters<IBaseSeries['getMarkerStyle']>[I];
export declare class RangeAreaSeries extends BaseSeries {
    static readonly className = "RangeAreaSeries";
    static readonly type: "range-area";
    properties: RangeAreaProperties;
    protected readonly NodeEvent: typeof RangeAreaSeriesNodeEvent;
    private readonly aggregationManager;
    constructor(moduleCtx: _ModuleSupport.ModuleContext);
    processData(dataController: _ModuleSupport.DataController): Promise<void>;
    private aggregateData;
    private estimateTargetRange;
    /**
     * Creates the context object for efficient node datum creation.
     * Caches expensive-to-compute values that are reused across all datum iterations.
     */
    private createNodeDatumContext;
    xCoordinateRange(xValue: any): [number, number];
    yCoordinateRange(yValues: any[]): [number, number];
    getSeriesDomain(direction: ChartAxisDirection): DomainWithMetadata<any>;
    getSeriesRange(_direction: ChartAxisDirection, visibleRange: [any, any]): any[];
    /**
     * Processes a single datum and updates the context's marker, label, and span arrays.
     * Uses the scratch object to avoid per-iteration allocations.
     *
     * @param yHighValueOverride - Optional override for yHighValue, used in aggregation mode
     *                             when the extreme values come from different data points
     * @param yLowValueOverride - Optional override for yLowValue, used in aggregation mode
     */
    private handleDatumPoint;
    /**
     * Creates or updates marker datum for a single boundary (high or low).
     * Supports incremental updates by reusing existing marker data objects when possible.
     */
    private upsertMarkerDatum;
    createNodeData(): RangeAreaContext | undefined;
    private createLabelData;
    protected isPathOrSelectionDirty(): boolean;
    protected strokewidthChange(): boolean;
    protected updatePathNodes(opts: {
        paths: _ModuleSupport.SegmentedPath[];
        visible: boolean;
        animationEnabled: boolean;
    }): void;
    protected updatePaths(opts: {
        contextData: RangeAreaContext;
        paths: _ModuleSupport.Path[];
    }): void;
    private updateAreaPaths;
    private updateFillPath;
    private updateStrokePath;
    protected resetDatumAnimation(data: _ModuleSupport.CartesianAnimationData<_ModuleSupport.Marker, RangeAreaMarkerDatum, RangeAreaLabelDatum, RangeAreaContext>): void;
    protected updateDatumSelection(opts: {
        nodeData: RangeAreaMarkerDatum[];
        datumSelection: _ModuleSupport.Selection<_ModuleSupport.Marker, RangeAreaMarkerDatum>;
    }): _ModuleSupport.Selection<_ModuleSupport.Marker, RangeAreaMarkerDatum>;
    protected updateDatumStyles({ datumSelection, isHighlight, }: {
        datumSelection: _ModuleSupport.Selection<_ModuleSupport.Marker, RangeAreaMarkerDatum>;
        isHighlight: boolean;
    }): void;
    protected updateDatumNodes(opts: {
        datumSelection: _ModuleSupport.Selection<_ModuleSupport.Marker, RangeAreaMarkerDatum>;
        isHighlight: boolean;
    }): void;
    protected updateLabelSelection(opts: {
        labelData: RangeAreaLabelDatum[];
        labelSelection: _ModuleSupport.Selection<_ModuleSupport.Text, RangeAreaLabelDatum>;
    }): _ModuleSupport.Selection<_ModuleSupport.Text<any>, RangeAreaLabelDatum>;
    protected updateLabelNodes(opts: {
        labelSelection: _ModuleSupport.Selection<_ModuleSupport.Text, RangeAreaLabelDatum>;
        isHighlight?: boolean;
    }): void;
    protected getHighlightLabelData(labelData: RangeAreaLabelDatum[], highlightedItem: RangeAreaMarkerDatum): RangeAreaLabelDatum[];
    protected getHighlightData(nodeData: RangeAreaMarkerDatum[], highlightedItem: RangeAreaMarkerDatum): RangeAreaMarkerDatum[] | undefined;
    private getStyle;
    private getStylerMarkerOptions;
    private getStylerCouple;
    private makeStylerParams;
    private makeItemStylerParams;
    getTooltipContent(datumIndex: number, removeThisDatum: RangeAreaMarkerDatum | undefined): _ModuleSupport.TooltipContent | undefined;
    private legendItemSymbol;
    getLegendData(legendType: _ModuleSupport.ChartLegendType): _ModuleSupport.CategoryLegendDatum[];
    protected isLabelEnabled(): boolean;
    protected nodeFactory(): _ModuleSupport.Marker;
    animateEmptyUpdateReady(animationData: _ModuleSupport.CartesianAnimationData<_ModuleSupport.Marker, RangeAreaMarkerDatum, RangeAreaLabelDatum, RangeAreaContext>): void;
    protected animateReadyResize(animationData: _ModuleSupport.CartesianAnimationData<_ModuleSupport.Marker, RangeAreaMarkerDatum, RangeAreaLabelDatum, RangeAreaContext>): void;
    animateWaitingUpdateReady(animationData: _ModuleSupport.CartesianAnimationData<_ModuleSupport.Marker, RangeAreaMarkerDatum, RangeAreaLabelDatum, RangeAreaContext>): void;
    getFormattedMarkerStyle(datum: RangeAreaMarkerDatum): AgSeriesMarkerStyle & {
        size: number;
    };
    getMarkerStyle<TParams>(marker: _ModuleSupport.SeriesMarker<TParams>, datum: GetMarkerStyleArg<1>, params?: TParams, opts?: GetMarkerStyleArg<3>, defaultOverrideStyle?: GetMarkerStyleArg<4>, inheritedStyle?: GetMarkerStyleArg<5>): ReturnType<IBaseSeries['getMarkerStyle']>;
    protected computeFocusBounds(opts: _ModuleSupport.PickFocusInputs): _ModuleSupport.BBox | undefined;
    protected isDatumEnabled(nodeData: RangeAreaMarkerDatum[], datumIndex: number): boolean;
    protected hasItemStylers(): boolean;
}
export {};
