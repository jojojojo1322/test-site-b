{"version":3,"sources":["../src/api/client.ts","../src/api/tokenManager.ts"],"names":[],"mappings":"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","file":"chunk-WFTMNXB3.js","sourcesContent":["import axios, {\n  AxiosHeaders,\n  type AxiosError,\n  type AxiosRequestConfig,\n  type AxiosResponse,\n  type InternalAxiosRequestConfig,\n} from \"axios\";\nimport type {\n  ApiClientOptions,\n  ManagedAxiosInstance,\n  RefreshQueueItem,\n  TokenManager,\n} from \"./types\";\n\ntype RetriableRequestConfig = InternalAxiosRequestConfig & { _retry?: boolean };\n\nconst resolvePromise = <T>(value: T | Promise<T>) => Promise.resolve(value);\n\nconst applyAuthHeader = (config: InternalAxiosRequestConfig, token: string) => {\n  const headers = AxiosHeaders.from(config.headers ?? new AxiosHeaders());\n  headers.set(\"Authorization\", `Bearer ${token}`);\n  config.headers = headers;\n};\n\nexport const createApiClient = (options: ApiClientOptions = {}): ManagedAxiosInstance => {\n  let tokenManager: TokenManager | undefined = options.tokenManager;\n  let isRefreshing = false;\n  const failedQueue: RefreshQueueItem[] = [];\n\n  const flushQueue = (error: unknown, token: string | null) => {\n    while (failedQueue.length) {\n      const queued = failedQueue.shift();\n      if (!queued) {\n        continue;\n      }\n      if (error) {\n        queued.reject(error);\n      } else {\n        queued.resolve(token);\n      }\n    }\n  };\n\n  const instance = axios.create({\n    baseURL: options.baseURL ?? \"/api\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      ...options.defaultHeaders,\n    },\n    timeout: 15_000,\n    ...options.axiosConfig,\n  });\n\n  instance.interceptors.request.use(async (config: InternalAxiosRequestConfig) => {\n    if (!tokenManager) {\n      return config;\n    }\n\n    const token = await resolvePromise(tokenManager.getAccessToken());\n    if (token) {\n      applyAuthHeader(config, token);\n    }\n\n    return config;\n  });\n\n  instance.interceptors.response.use(\n    (response: AxiosResponse) => response,\n    async (error: AxiosError) => {\n      const { response } = error;\n      const originalRequest = error.config as RetriableRequestConfig | undefined;\n\n      if (!response || !originalRequest || response.status !== 401 || !tokenManager?.refreshToken) {\n        if (response?.status === 401) {\n          tokenManager?.onUnauthorized?.();\n          tokenManager?.clear?.();\n        }\n        return Promise.reject(error);\n      }\n\n      if (originalRequest._retry) {\n        tokenManager?.onUnauthorized?.();\n        tokenManager?.clear?.();\n        return Promise.reject(error);\n      }\n\n      if (!isRefreshing) {\n        isRefreshing = true;\n        tokenManager\n          .refreshToken()\n          .then((token) => {\n            if (!token) {\n              throw new Error(\"Failed to refresh token: empty payload\");\n            }\n            tokenManager?.setAccessToken?.(token);\n            flushQueue(null, token);\n          })\n          .catch((refreshError) => {\n            flushQueue(refreshError, null);\n            tokenManager?.onUnauthorized?.();\n            tokenManager?.clear?.();\n          })\n          .finally(() => {\n            isRefreshing = false;\n          });\n      }\n\n      return new Promise((resolve, reject) => {\n        failedQueue.push({\n          resolve: (token) => {\n            if (!token) {\n              reject(error);\n              return;\n            }\n            applyAuthHeader(originalRequest, token);\n            originalRequest._retry = true;\n            resolve(instance(originalRequest as AxiosRequestConfig));\n          },\n          reject,\n        });\n      });\n    }\n  );\n\n  const managedInstance = instance as ManagedAxiosInstance;\n  managedInstance.setTokenManager = (manager?: TokenManager) => {\n    tokenManager = manager;\n  };\n\n  return managedInstance;\n};\n\nexport type { ApiClientOptions } from \"./types\";\n","import type { InMemoryTokenManagerOptions, TokenManager } from \"./types\";\n\nexport const createInMemoryTokenManager = (\n  options: InMemoryTokenManagerOptions = {}\n): TokenManager => {\n  let accessToken = options.accessToken ?? null;\n\n  return {\n    getAccessToken: () => accessToken,\n    refreshToken: options.refresh\n      ? async () => {\n          accessToken = await options.refresh!();\n          return accessToken;\n        }\n      : undefined,\n    setAccessToken: (token) => {\n      accessToken = token;\n    },\n    clear: () => {\n      accessToken = null;\n    },\n    onUnauthorized: options.onUnauthorized,\n  };\n};\n"]}