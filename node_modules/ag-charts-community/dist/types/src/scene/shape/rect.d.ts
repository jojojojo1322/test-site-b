import { type DistantObject } from 'ag-charts-core';
import type { AgDrawingMode } from 'ag-charts-types';
import { BBox } from '../bbox';
import type { DropShadow } from '../dropShadow';
import { ExtendedPath2D } from '../extendedPath2D';
import { Path } from './path';
import { type CanvasContext } from './shape';
export interface CornerRadii {
    topLeft: number;
    topRight: number;
    bottomRight: number;
    bottomLeft: number;
}
export declare function clippedRoundRect(path: ExtendedPath2D, x: number, y: number, width: number, height: number, cornerRadii: CornerRadii, clipBBox: BBox | undefined): void;
export declare class Rect<D = any> extends Path<D> implements DistantObject {
    static readonly className: string;
    readonly borderPath: ExtendedPath2D;
    x: number;
    __x: number;
    y: number;
    __y: number;
    width: number;
    __width: number;
    height: number;
    __height: number;
    topLeftCornerRadius: number;
    __topLeftCornerRadius: number;
    topRightCornerRadius: number;
    __topRightCornerRadius: number;
    bottomRightCornerRadius: number;
    __bottomRightCornerRadius: number;
    bottomLeftCornerRadius: number;
    __bottomLeftCornerRadius: number;
    set cornerRadius(cornerRadius: number);
    clipBBox?: BBox;
    __clipBBox: BBox | undefined;
    /**
     * If `true`, the rect is aligned to the pixel grid for crisp looking lines.
     * Animated rects may not look nice with this option enabled, for example
     * when a rect is translated by a sub-pixel value on each frame.
     */
    crisp: boolean;
    __crisp: boolean;
    private borderClipPath?;
    private lastUpdatePathStrokeWidth;
    protected isDirtyPath(): boolean;
    private effectiveStrokeWidth;
    private hittester;
    private distanceCalculator;
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    protected microPixelEffectOpacity: number;
    updatePath(): void;
    protected computeBBox(): BBox;
    isPointInPath(x: number, y: number): boolean;
    get midPoint(): {
        x: number;
        y: number;
    };
    /**
     * High-performance static property setter that bypasses the decorator system entirely.
     * Writes directly to backing fields (__propertyName) to avoid:
     * - Decorator setter chains and equality checks
     * - Multiple onChangeDetection calls per property
     * - Object.keys() iteration in assignIfNotStrictlyEqual
     * - Object allocation overhead
     *
     * A single markDirty() call at the end ensures the scene graph is properly invalidated.
     * WARNING: Only use for hot paths where performance is critical and properties don't need
     * individual change detection (e.g., when updating many nodes in a loop).
     */
    setStaticProperties(drawingMode: AgDrawingMode, topLeftCornerRadius: number, topRightCornerRadius: number, bottomRightCornerRadius: number, bottomLeftCornerRadius: number, visible: boolean, crisp: boolean, fillShadow: DropShadow | undefined): void;
    /**
     * High-performance animation reset that bypasses the decorator system entirely.
     * Writes directly to backing fields (__x, __y, etc.) to avoid:
     * - Decorator setter chains and equality checks
     * - Multiple onChangeDetection calls
     * - Object.keys() iteration
     *
     * A single markDirty() call at the end ensures the scene graph is properly invalidated.
     * WARNING: Only use for animation hot paths where performance is critical.
     */
    resetAnimationProperties(x: number, y: number, width: number, height: number, opacity: number, clipBBox: BBox | undefined): void;
    distanceSquared(x: number, y: number): number;
    protected applyFillAndAlpha(ctx: CanvasRenderingContext2D): void;
    protected applyStrokeAndAlpha(ctx: CanvasContext): void;
    protected renderStroke(ctx: CanvasRenderingContext2D & {
        setLineDash(lineDash: readonly number[]): void;
    }): void;
}
