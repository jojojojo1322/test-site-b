import { type ColorSpace, type InternalAgGradientColor } from 'ag-charts-core';
import type { AgDrawingMode, AgImageFill, AgPatternColor, CssColor } from 'ag-charts-types';
import type { BBox } from '../bbox';
import type { DropShadow } from '../dropShadow';
import { Gradient, type GradientParams } from '../gradient/gradient';
import { Image } from '../image/image';
import { Node } from '../node';
import { Pattern } from '../pattern/pattern';
export type ShapeLineCap = 'butt' | 'round' | 'square';
export type ShapeLineJoin = 'round' | 'bevel' | 'miter';
export type CanvasContext = CanvasFillStrokeStyles & CanvasCompositing & CanvasShadowStyles & CanvasPathDrawingStyles & CanvasDrawPath & CanvasPath & CanvasTransform & CanvasState;
export type ShapeGradientColor = Omit<InternalAgGradientColor, 'bounds'> & {
    colorSpace?: ColorSpace;
};
export type ShapeColor = CssColor | ShapeGradientColor | AgPatternColor | AgImageFill;
export declare abstract class Shape<TDatum = unknown> extends Node<TDatum> {
    drawingMode: AgDrawingMode;
    __drawingMode: AgDrawingMode;
    fillOpacity: number;
    __fillOpacity: number;
    strokeOpacity: number;
    __strokeOpacity: number;
    fill: ShapeColor | undefined;
    __fill: ShapeColor | undefined;
    private getGradient;
    private createGradient;
    private getPattern;
    private createPattern;
    private getImage;
    private createImage;
    private _cachedFill?;
    protected onFillChange(): void;
    protected fillGradient: Gradient | undefined;
    protected fillPattern: Pattern | undefined;
    protected fillImage: Image | undefined;
    /**
     * Note that `strokeStyle = null` means invisible stroke,
     * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.
     * For example, a rect shape with an invisible stroke may not align to the pixel grid
     * properly because the stroke affects the rules of alignment, and arc shapes forming
     * a pie chart will have a gap between them if they have an invisible stroke, whereas
     * there would be not gap if there was no stroke at all.
     * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,
     * unless specific looks that is achieved by having an invisible stroke is desired.
     */
    stroke?: ShapeColor;
    __stroke: ShapeColor | undefined;
    protected onStrokeChange(): void;
    protected strokeGradient?: Gradient;
    strokeWidth: number;
    __strokeWidth: number;
    /**
     * Returns a device-pixel aligned coordinate (or length if length is supplied).
     *
     * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
     * of a device pixel.
     */
    align(start: number, length?: number): number;
    lineDash?: readonly number[];
    __lineDash: readonly number[] | undefined;
    lineDashOffset: number;
    __lineDashOffset: number;
    lineCap?: ShapeLineCap;
    __lineCap: ShapeLineCap | undefined;
    lineJoin?: ShapeLineJoin;
    __lineJoin: ShapeLineJoin | undefined;
    miterLimit?: number;
    __miterLimit: number | undefined;
    opacity: number;
    __opacity: number;
    fillShadow: DropShadow | undefined;
    __fillShadow: DropShadow | undefined;
    fillBBox?: BBox;
    __fillBBox: BBox | undefined;
    fillParams?: GradientParams;
    __fillParams: GradientParams | undefined;
    private cachedDefaultGradientFillBBox?;
    markDirty(property?: string): void;
    protected fillStroke(ctx: CanvasContext, path?: Path2D): void;
    protected renderFill(ctx: CanvasContext, path?: Path2D): void;
    protected executeFill(ctx: CanvasContext, path?: Path2D): void;
    protected applyFillAndAlpha(ctx: CanvasContext): void;
    protected applyStrokeAndAlpha(ctx: CanvasContext): void;
    protected applyShadow(ctx: CanvasContext): void;
    protected renderStroke(ctx: CanvasContext & {
        setLineDash(lineDash: readonly number[]): void;
    }, path?: Path2D): void;
    protected executeStroke(ctx: CanvasContext, path?: Path2D): void;
    getDefaultGradientFillBBox(): BBox;
    protected computeDefaultGradientFillBBox(): BBox | undefined;
    containsPoint(x: number, y: number): boolean;
    abstract isPointInPath(x: number, y: number): boolean;
    protected applySvgFillAttributes(element: SVGElement, defs?: SVGElement[]): SVGElement[] | undefined;
    protected applySvgStrokeAttributes(element: SVGElement): void;
    private static handleFillChange;
    private static handleStrokeChange;
    /**
     * Sets style properties on the shape, optimizing by writing directly to __ prefix fields
     * where possible to avoid setter overhead.
     */
    setStyleProperties(style?: Partial<Pick<Shape, 'fill' | 'fillOpacity' | 'stroke' | 'strokeOpacity' | 'strokeWidth' | 'lineDash' | 'lineDashOffset' | 'opacity'>>, fillBBox?: {
        series: BBox;
        axis: BBox;
    }, fillParams?: GradientParams): void;
    /**
     * Sets fill-related properties (fillBBox and fillParams) on the shape.
     * Used for gradient fills that need bounding box information.
     */
    setFillProperties(fill: ShapeColor | undefined, fillBBox?: {
        series: BBox;
        axis: BBox;
    }, fillParams?: GradientParams): void;
}
