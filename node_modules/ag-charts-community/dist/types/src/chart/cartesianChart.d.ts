import type { ChartOptions } from '../module/optionsModule';
import type { BBox } from '../scene/bbox';
import { CartesianAxis } from './axis/cartesianAxis';
import type { TransferableResources } from './chart';
import { Chart } from './chart';
import { CartesianChartAxes } from './chartAxes';
import type { LayoutContext } from './layout/layoutManager';
import type { UnknownSeries } from './series/series';
export declare class CartesianChart extends Chart {
    static readonly className = "CartesianChart";
    static readonly type = "cartesian";
    private static readonly AxesPadding;
    /** Integrated Charts feature state - not used in Standalone Charts. */
    readonly paired: boolean;
    axes: CartesianChartAxes;
    createChartAxes(): CartesianChartAxes;
    private lastAreaWidths?;
    constructor(options: ChartOptions, resources?: TransferableResources);
    onAxisChange(newValue: CartesianAxis[], oldValue?: CartesianAxis[]): void;
    destroySeries(series: UnknownSeries[]): void;
    getChartType(): "cartesian";
    private setRootClipRects;
    private lastUpdateClipRect;
    processData(): Promise<void>;
    processDomains(): Promise<void>;
    private lastLayoutWidth;
    private lastLayoutHeight;
    protected performLayout(ctx: LayoutContext): void;
    updateAxes(layoutBox: BBox): {
        clipSeries: boolean;
        seriesRect: BBox;
        visible: boolean;
    };
    private resolveAxesLayout;
    private updateAxesPass;
    private calculateAxesCrossPositions;
    private calculateAxisCrossPosition;
    private adjustAxisWidth;
    private calculateAxisBleedingWidth;
    private applyAxisCrossing;
    private buildCrossLinePadding;
    private clampToOutsideSeriesRect;
    private getSyncedDomain;
    private syncAxisChanges;
    private sizeAxis;
    private positionAxes;
    private shouldFlipXY;
    private getDefaultState;
    private isLayoutStable;
    private clipAxis;
}
