import type { ScaleType } from 'ag-charts-core';
import type { DataModel } from '../../data/dataModel';
import type { ProcessedData, ScopeProvider } from '../../data/dataModelTypes';
export interface BarSeriesDataAggregationFilter {
    maxRange: number;
    positiveIndices: Uint32Array;
    positiveIndexData: Uint32Array;
    positiveValueData: Float64Array;
    negativeIndices: Uint32Array;
    negativeIndexData: Uint32Array;
    negativeValueData: Float64Array;
    stale?: boolean;
}
export interface PartialBarAggregationResult {
    /** Levels computed immediately (includes the target level) */
    immediate: BarSeriesDataAggregationFilter[];
    /** Function to compute remaining coarser levels, or undefined if all levels computed */
    computeRemaining?: () => BarSeriesDataAggregationFilter[];
}
/**
 * Computes multi-level aggregation filters for bar chart data.
 *
 * Creates progressively coarser aggregation levels for efficient rendering
 * of large datasets. Bar series requires separate aggregation for positive
 * and negative values to properly handle stacked bars and bi-directional data.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param yStartValues - Y start values for stacked bars (or undefined for non-stacked)
 * @param yEndValues - Y end values
 * @param options - Configuration options
 * @param options.smallestKeyInterval - Smallest interval between X keys (for category axes)
 * @param options.xNeedsValueOf - Whether X values need valueOf() conversion
 * @param options.yNeedsValueOf - Whether Y values need valueOf() conversion
 * @returns Array of aggregation filters from coarse to fine resolution, or undefined if below threshold
 *
 * @complexity O(n * log(levels)) where n is data points and levels â‰ˆ log2(maxRange/64)
 * @memory Creates TypedArrays for both positive and negative aggregations
 *
 * @example
 * const filters = computeBarAggregation(
 *   [0, 100],
 *   [1, 2, 3, ...1000],
 *   undefined,
 *   [10, -5, 20, ...50],
 *   { smallestKeyInterval: undefined, xNeedsValueOf: false, yNeedsValueOf: false }
 * );
 * // Returns filters with separate positive/negative indices for efficient rendering
 */
export declare function computeBarAggregation(domain: [number, number], xValues: any[], yStartValues: any[] | undefined, yEndValues: any[], options: {
    smallestKeyInterval: number | undefined;
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    existingFilters?: BarSeriesDataAggregationFilter[];
}): BarSeriesDataAggregationFilter[] | undefined;
/**
 * Computes bar aggregation with deferred full recomputation.
 *
 * For real-time data updates, this computes only the single aggregation level
 * needed for the current zoom, deferring a full recomputation of all levels
 * to idle time. This design enables future incremental updates to focus on
 * just the immediate level, while deferred processing handles full rebuilds.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param yStartValues - Y start values for stacked bars
 * @param yEndValues - Y end values
 * @param options - Configuration options including targetRange
 * @param options.targetRange - The current pixel range for determining bucket count
 * @returns Partial result with the immediate level and a function to compute all levels
 */
export declare function computeBarAggregationPartial(domain: [number, number], xValues: any[], yStartValues: any[] | undefined, yEndValues: any[], options: {
    smallestKeyInterval: number | undefined;
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    targetRange: number;
    existingFilters?: BarSeriesDataAggregationFilter[];
}): PartialBarAggregationResult | undefined;
/**
 * High-level aggregation function for series integration.
 * Handles data extraction from DataModel and delegates to aggregation.
 *
 * @param scale - The X-axis scale type
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param series - Series context for data model queries
 * @param existingFilters - Optional existing filters for array reuse
 * @returns Aggregation filters or undefined if aggregation not needed
 */
export declare function aggregateBarDataFromDataModel(scale: ScaleType, dataModel: DataModel<any, any, any>, processedData: ProcessedData<any>, series: ScopeProvider, existingFilters?: BarSeriesDataAggregationFilter[]): BarSeriesDataAggregationFilter[] | undefined;
/**
 * High-level partial aggregation function for series integration.
 * Computes immediate levels for the target range and defers coarser levels.
 *
 * @param scale - The X-axis scale type
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param series - Series context for data model queries
 * @param targetRange - Current pixel range for determining which levels to compute immediately
 * @param existingFilters - Optional existing filters for array reuse
 * @returns Partial aggregation result with immediate levels and deferred computation function
 */
export declare function aggregateBarDataFromDataModelPartial(scale: ScaleType, dataModel: DataModel<any, any, any>, processedData: ProcessedData<any>, series: ScopeProvider, targetRange: number, existingFilters?: BarSeriesDataAggregationFilter[]): PartialBarAggregationResult | undefined;
