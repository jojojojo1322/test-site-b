import { type ScaleType } from 'ag-charts-core';
import type { DataModel } from '../../data/dataModel';
import type { ProcessedData, ScopeProvider } from '../../data/dataModelTypes';
export interface AreaSeriesDataAggregationFilter {
    metaIndices: Uint32Array;
    indices: Uint32Array;
    maxRange: number;
    indexData: Uint32Array;
    valueData: Float64Array;
    stale?: boolean;
}
export interface PartialAreaAggregationResult {
    /** Levels computed immediately (includes the target level) */
    immediate: AreaSeriesDataAggregationFilter[];
    /** Function to compute remaining coarser levels, or undefined if all levels computed */
    computeRemaining?: () => AreaSeriesDataAggregationFilter[];
}
/**
 * Computes multi-level aggregation filters for area chart data.
 *
 * Creates progressively coarser aggregation levels for efficient rendering
 * of large datasets. Each filter level tracks indices of extrema (min/max X/Y)
 * within buckets, plus metaIndices to preserve group boundaries for proper
 * area fill rendering.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param yValues - Y coordinate values
 * @param options - Configuration options
 * @param options.xNeedsValueOf - Whether X values need valueOf() conversion
 * @param options.yNeedsValueOf - Whether Y values need valueOf() conversion
 * @param options.existingFilters - Optional existing filters for TypedArray reuse
 * @returns Array of aggregation filters from coarse to fine resolution, or undefined if below threshold
 *
 * @complexity O(n * log(levels)) where n is data points and levels â‰ˆ log2(maxRange/64)
 * @memory Creates TypedArrays proportional to data size
 *
 * @example
 * const filters = computeAreaAggregation(
 *   [0, 100],
 *   [1, 2, 3, ...1000],
 *   [10, 20, 15, ...50],
 *   { xNeedsValueOf: false, yNeedsValueOf: false }
 * );
 * // Returns filters with extrema indices and group boundaries for efficient rendering
 */
export declare function computeAreaAggregation(domain: [number, number], xValues: any[], yValues: any[], options: {
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    existingFilters?: AreaSeriesDataAggregationFilter[];
}): AreaSeriesDataAggregationFilter[] | undefined;
/**
 * Computes area aggregation with deferred full recomputation.
 *
 * For real-time data updates, this computes only the single aggregation level
 * needed for the current zoom, deferring a full recomputation of all levels
 * to idle time.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param yValues - Y coordinate values
 * @param options - Configuration options including targetRange
 * @returns Partial result with the immediate level and a function to compute all levels
 */
export declare function computeAreaAggregationPartial(domain: [number, number], xValues: any[], yValues: any[], options: {
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    targetRange: number;
    existingFilters?: AreaSeriesDataAggregationFilter[];
}): PartialAreaAggregationResult | undefined;
/**
 * High-level aggregation function for series integration.
 * Handles data extraction from DataModel and delegates to memoized aggregation.
 *
 * @param scale - The X-axis scale
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param yKey - The Y value key to use (e.g., 'yValue', 'yValueCumulative')
 * @param series - Series context for data model queries
 * @param existingFilters - Optional existing filters for TypedArray reuse
 * @returns Aggregation filters or undefined if aggregation not needed
 */
export declare function aggregateAreaDataFromDataModel(scale: ScaleType, dataModel: DataModel<any, any, any>, processedData: ProcessedData<any>, yKey: string, series: ScopeProvider, existingFilters?: AreaSeriesDataAggregationFilter[]): AreaSeriesDataAggregationFilter[] | undefined;
/**
 * High-level partial aggregation function for series integration.
 * Computes immediate levels for the target range and defers coarser levels.
 *
 * @param scale - The X-axis scale type
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param yKey - The Y value key to use (e.g., 'yValue', 'yValueCumulative')
 * @param series - Series context for data model queries
 * @param targetRange - Current pixel range for determining which levels to compute immediately
 * @param existingFilters - Optional existing filters for TypedArray reuse
 * @returns Partial aggregation result with immediate levels and deferred computation function
 */
export declare function aggregateAreaDataFromDataModelPartial(scale: ScaleType, dataModel: DataModel<any, any, any>, processedData: ProcessedData<any>, yKey: string, series: ScopeProvider, targetRange: number, existingFilters?: AreaSeriesDataAggregationFilter[]): PartialAreaAggregationResult | undefined;
