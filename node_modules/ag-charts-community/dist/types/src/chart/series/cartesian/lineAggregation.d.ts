import { type ScaleType } from 'ag-charts-core';
import type { DataModel } from '../../data/dataModel';
import type { ProcessedData, ScopeProvider } from '../../data/dataModelTypes';
export interface LineSeriesDataAggregationFilter {
    maxRange: number;
    indices: Uint32Array;
    indexData: Uint32Array;
    valueData: Float64Array;
    stale?: boolean;
}
export interface PartialLineAggregationResult {
    /** Levels computed immediately (includes the target level) */
    immediate: LineSeriesDataAggregationFilter[];
    /** Function to compute remaining coarser levels, or undefined if all levels computed */
    computeRemaining?: () => LineSeriesDataAggregationFilter[];
}
/**
 * Computes multi-level aggregation filters for line chart data.
 *
 * Creates progressively coarser aggregation levels for efficient rendering
 * of large datasets. Each filter level tracks indices of extrema (min/max X/Y)
 * within buckets, allowing the renderer to skip intermediate points while
 * preserving the visual envelope of the line.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param yValues - Y coordinate values
 * @param options - Configuration options
 * @param options.xNeedsValueOf - Whether X values need valueOf() conversion
 * @param options.yNeedsValueOf - Whether Y values need valueOf() conversion
 * @param options.existingFilters - Optional existing filters for array reuse
 * @returns Array of aggregation filters from coarse to fine resolution, or undefined if below threshold
 *
 * @complexity O(n * log(levels)) where n is data points and levels â‰ˆ log2(maxRange/64)
 * @memory Creates TypedArrays proportional to data size
 */
export declare function computeLineAggregation(domain: [number, number], xValues: any[], yValues: any[], options: {
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    existingFilters?: LineSeriesDataAggregationFilter[];
}): LineSeriesDataAggregationFilter[] | undefined;
/**
 * Computes line aggregation with deferred full recomputation.
 *
 * For real-time data updates, this computes only the single aggregation level
 * needed for the current zoom, deferring a full recomputation of all levels
 * to idle time.
 *
 * @param domain - Numeric domain bounds [min, max] for X values
 * @param xValues - X coordinate values
 * @param yValues - Y coordinate values
 * @param options - Configuration options including targetRange
 * @returns Partial result with the immediate level and a function to compute all levels
 */
export declare function computeLineAggregationPartial(domain: [number, number], xValues: any[], yValues: any[], options: {
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
    targetRange: number;
    existingFilters?: LineSeriesDataAggregationFilter[];
}): PartialLineAggregationResult | undefined;
/**
 * High-level aggregation function for series integration.
 * Handles data extraction from DataModel and delegates to aggregation.
 *
 * @param scale - The X-axis scale type
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param yKey - The Y value key to use (e.g., 'yValue', 'yValueCumulative')
 * @param series - Series context for data model queries
 * @param existingFilters - Optional existing filters for array reuse
 * @returns Aggregation filters or undefined if aggregation not needed
 */
export declare function aggregateLineDataFromDataModel(scale: ScaleType, dataModel: DataModel<any, any, any>, processedData: ProcessedData<any>, yKey: string, series: ScopeProvider, existingFilters?: LineSeriesDataAggregationFilter[]): LineSeriesDataAggregationFilter[] | undefined;
/**
 * High-level partial aggregation function for series integration.
 * Computes immediate levels for the target range and defers coarser levels.
 *
 * @param scale - The X-axis scale type
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param yKey - The Y value key to use (e.g., 'yValue', 'yValueCumulative')
 * @param series - Series context for data model queries
 * @param targetRange - Current pixel range for determining which levels to compute immediately
 * @param existingFilters - Optional existing filters for array reuse
 * @returns Partial aggregation result with immediate levels and deferred computation function
 */
export declare function aggregateLineDataFromDataModelPartial(scale: ScaleType, dataModel: DataModel<any, any, any>, processedData: ProcessedData<any>, yKey: string, series: ScopeProvider, targetRange: number, existingFilters?: LineSeriesDataAggregationFilter[]): PartialLineAggregationResult | undefined;
