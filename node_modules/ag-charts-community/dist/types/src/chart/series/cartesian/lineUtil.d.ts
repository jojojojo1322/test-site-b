import type { InterpolationProperties, Point, Span } from 'ag-charts-core';
import type { AgSeriesMarkerStyle, TextOrSegments } from 'ag-charts-types';
import { type FromToFns, type NodeUpdateState } from '../../../motion/fromToMotion';
import type { Path } from '../../../scene/shape/path';
import type { Segment } from '../../../scene/shape/segmentedPath';
import type { ProcessedOutputDiff } from '../../data/dataModel';
import type { SeriesNodeStyleContext } from '../series';
import type { ErrorBoundSeriesNodeDatum } from '../seriesTypes';
import type { CartesianSeriesNodeDataContext, CartesianSeriesNodeDatum } from './cartesianSeries';
import { type SpanInterpolation } from './lineInterpolationUtil';
export interface LinePathSpan {
    span: Span;
    xValue0: any;
    yValue0: any;
    xValue1: any;
    yValue1: any;
}
export interface LineStrokePathDatum {
    readonly spans: LinePathSpan[];
    readonly itemId: string;
}
export interface SpanAnimation {
    added: SpanInterpolation[];
    moved: SpanInterpolation[];
    removed: SpanInterpolation[];
}
export interface LineSpanPointDatum {
    point: Point;
    xDatum: any;
    yDatum: any;
}
export interface LineNodeDatum extends CartesianSeriesNodeDatum, ErrorBoundSeriesNodeDatum {
    readonly itemId?: never;
    readonly xValue: NonNullable<CartesianSeriesNodeDatum['xValue']>;
    readonly yValue: NonNullable<CartesianSeriesNodeDatum['yValue']>;
    readonly point: NonNullable<CartesianSeriesNodeDatum['point']>;
    readonly labelText?: TextOrSegments;
    readonly selected: boolean | undefined;
    style?: AgSeriesMarkerStyle;
}
export interface LineSeriesNodeDataContext extends CartesianSeriesNodeDataContext<LineNodeDatum> {
    strokeData: LineStrokePathDatum;
    crossFiltering: boolean;
    styles: SeriesNodeStyleContext<AgSeriesMarkerStyle>;
    segments?: Segment[];
}
/**
 * Context object for efficient node datum creation.
 * Caches expensive-to-compute values that are reused across all datum iterations
 * to minimize memory allocations. Only caches values that are expensive to
 * compute - cheap property lookups use `this` directly in methods.
 */
export interface LineSeriesDatumContext {
    readonly rawData: any[];
    readonly xValues: any[];
    readonly yRawValues: any[];
    readonly yCumulativeValues: any[];
    readonly selectionValues: any[] | undefined;
    readonly xScale: {
        convert: (v: any) => number;
        bandwidth?: number;
        range: number[];
    };
    readonly yScale: {
        convert: (v: any) => number;
        bandwidth?: number;
    };
    readonly xOffset: number;
    readonly yOffset: number;
    readonly size: number;
    readonly yDomain: any[];
    readonly labelsEnabled: boolean;
    readonly animationEnabled: boolean;
    readonly canIncrementallyUpdate: boolean;
    readonly dataAggregationFilter: {
        indices: Uint32Array;
    } | undefined;
    readonly range: number;
    readonly xKey: string;
    readonly yKey: string;
    readonly xName: string | undefined;
    readonly yName: string | undefined;
    readonly legendItemName: string | undefined;
    readonly connectMissingData: boolean;
    readonly capDefaults: {
        lengthRatioMultiplier: number;
        lengthMax: number;
    };
    nodeData: LineNodeDatum[];
    spanPoints: Array<LineSpanPointDatum[] | {
        skip: number;
    }>;
    nodeIndex: number;
}
/**
 * Scratch object for temporary datum state during node creation.
 * Reused across iterations to avoid per-datum allocations.
 */
export interface LineNodeDatumScratch {
    datum: any;
    xDatum: any;
    yDatum: any;
    yCumulative: number;
    selected: boolean | undefined;
    x: number;
    y: number;
}
export declare function interpolatePoints(points: LineSpanPointDatum[], interpolation: InterpolationProperties): LinePathSpan[];
export declare function pointsEq(a: Point, b: Point, delta?: number): boolean;
export declare function plotLinePathStroke({ path }: Path, spans: LinePathSpan[]): void;
export declare function plotInterpolatedLinePathStroke(ratio: number, path: Path, spans: SpanInterpolation[]): void;
export declare function prepareLinePathStrokeAnimationFns(status: NodeUpdateState, spans: SpanAnimation, visibleToggleMode: 'fade' | 'none'): {
    status: NodeUpdateState;
    path: {
        addPhaseFn: (ratio: number, path: Path) => void;
        updatePhaseFn: (ratio: number, path: Path) => void;
        removePhaseFn: (ratio: number, path: Path) => void;
    };
    pathProperties: FromToFns<Path<any>, any, unknown>;
};
export declare function prepareLinePathPropertyAnimation(status: NodeUpdateState, visibleToggleMode: 'fade' | 'none'): FromToFns<Path, any, unknown>;
export declare function prepareLinePathAnimation(newData: LineSeriesNodeDataContext, oldData: LineSeriesNodeDataContext, diff: ProcessedOutputDiff | undefined): {
    status: NodeUpdateState;
    stroke: {
        status: NodeUpdateState;
        path: {
            addPhaseFn: (ratio: number, path: Path<any>) => void;
            updatePhaseFn: (ratio: number, path: Path<any>) => void;
            removePhaseFn: (ratio: number, path: Path<any>) => void;
        };
        pathProperties: FromToFns<Path<any>, any, unknown>;
    };
    hasMotion: boolean;
} | undefined;
