import type { ScaleType } from 'ag-charts-core';
export interface BubbleAggregation {
    xValues: any[];
    yValues: any[];
    xd0: number;
    xd1: number;
    yd0: number;
    yd1: number;
    filters: BubbleAggregationFilter[];
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
}
export interface BubbleAggregationFilter {
    sizeRatio: number;
    node: BubbleAggregationNode | null;
}
export interface BubbleAggregationNode {
    scale: number;
    x0: any;
    y0: any;
    x1: any;
    y1: any;
    indices: number[];
    primaryDatumIndex: number;
    children: BubbleAggregationNode[] | null;
}
/**
 * Computes quadtree-based spatial aggregation for bubble chart data.
 *
 * Creates a hierarchical quadtree structure to efficiently render large bubble
 * datasets by grouping spatially-close bubbles. Unlike linear series aggregation,
 * this uses 2D spatial partitioning with optional size-based quantization.
 *
 * @param xDomain - X domain bounds [min, max]
 * @param yDomain - Y domain bounds [min, max]
 * @param xValues - X coordinate values
 * @param yValues - Y coordinate values
 * @param sizeValues - Bubble size values (optional)
 * @param sizeDomain - Size domain [min, max]
 * @param options - Configuration options
 * @param options.xNeedsValueOf - Whether X values need valueOf() conversion
 * @param options.yNeedsValueOf - Whether Y values need valueOf() conversion
 * @returns Bubble aggregation with quadtree nodes, or undefined if no aggregation possible
 *
 * @complexity O(n log n) for quadtree construction where n is data points
 * @memory Creates hierarchical node structure proportional to spatial distribution
 *
 * @example
 * const aggregation = computeBubbleAggregation(
 *   [0, 100], [0, 100],
 *   xData, yData, sizeData,
 *   [10, 50],
 *   { xNeedsValueOf: false, yNeedsValueOf: false }
 * );
 * // Returns quadtree with spatially-grouped bubble indices
 */
export declare function computeBubbleAggregation(xDomain: [number, number], yDomain: [number, number], xValues: any[], yValues: any[], sizeValues: any[] | undefined, sizeDomain: [number, number], options: {
    xNeedsValueOf: boolean;
    yNeedsValueOf: boolean;
}): BubbleAggregation | undefined;
/**
 * High-level aggregation function for series integration.
 * Handles data extraction from DataModel and delegates to aggregation.
 *
 * @param xScale - The X-axis scale type
 * @param yScale - The Y-axis scale type
 * @param dataModel - Data model containing the processed data
 * @param processedData - Processed data to aggregate
 * @param sizeScale - Size scale for bubble sizing
 * @param hasSizeKey - Whether size key is defined
 * @param series - Series context for data model queries
 * @returns Bubble aggregation or undefined if aggregation not needed
 */
export declare function aggregateBubbleDataFromDataModel(xScale: ScaleType, yScale: ScaleType, dataModel: any, processedData: any, sizeScale: any, hasSizeKey: boolean, series: any): BubbleAggregation | undefined;
export interface BubbleAggregationOptions {
    xRange: number;
    yRange: number;
    xVisibleRange: [number, number];
    yVisibleRange: [number, number];
    minSize: number;
    maxSize: number;
}
export interface GroupedAggregation {
    datumIndex: number;
    count: number;
    area: number;
    dilation: number;
}
export declare function computeBubbleAggregationCount(dilation: number, dataAggregation: BubbleAggregation, options: BubbleAggregationOptions): number;
export declare function computeBubbleAggregationDilation(dataAggregation: BubbleAggregation, aggregationOptions: BubbleAggregationOptions, maxRenderedItems: number): number;
export declare function computeBubbleAggregationData(dilation: number, dataAggregation: BubbleAggregation, options: BubbleAggregationOptions): {
    groupedAggregation: GroupedAggregation[];
    singleDatumIndices: number[];
};
