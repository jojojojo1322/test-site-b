import type { DomainWithMetadata, Point } from 'ag-charts-core';
import { ChartAxisDirection } from 'ag-charts-core';
import type { AgBarSeriesOptions, AgBarSeriesStyle, TextOrSegments } from 'ag-charts-types';
import type { ModuleContext } from '../../../module/moduleContext';
import { BBox } from '../../../scene/bbox';
import { Group } from '../../../scene/group';
import { Selection } from '../../../scene/selection';
import { BarShape } from '../../../scene/shape/barShape';
import type { Segment } from '../../../scene/shape/segmentedPath';
import type { Text } from '../../../scene/shape/text';
import type { DataController } from '../../data/dataController';
import type { CategoryLegendDatum, ChartLegendType } from '../../legend/legendDatum';
import { type TooltipContent } from '../../tooltip/tooltip';
import { type PickFocusInputs, type SeriesNodeStyleContext } from '../series';
import { HighlightState } from '../seriesProperties';
import type { ErrorBoundSeriesNodeDatum } from '../seriesTypes';
import { AbstractBarSeries, type AbstractBarSeriesAnimationData, type AbstractBarSeriesNodeDataContext } from './abstractBarSeries';
import { BarSeriesProperties } from './barSeriesProperties';
import { type CartesianAnimationData, type CartesianSeriesNodeDatum } from './cartesianSeries';
interface BarNodeLabelDatum extends Readonly<Point> {
    readonly text: TextOrSegments;
    readonly textAlign: CanvasTextAlign;
    readonly textBaseline: CanvasTextBaseline;
}
interface BarNodeDatum extends CartesianSeriesNodeDatum, ErrorBoundSeriesNodeDatum, Readonly<Point> {
    readonly itemId: string;
    readonly xValue: string | number;
    readonly yValue: string | number;
    readonly cumulativeValue: number;
    readonly phantom: boolean;
    readonly width: number;
    readonly height: number;
    readonly opacity: number | undefined;
    readonly topLeftCornerRadius: boolean;
    readonly topRightCornerRadius: boolean;
    readonly bottomRightCornerRadius: boolean;
    readonly bottomLeftCornerRadius: boolean;
    readonly featherRatio: number;
    readonly clipBBox: BBox | undefined;
    readonly crisp: boolean;
    readonly label?: BarNodeLabelDatum;
    style?: Required<AgBarSeriesStyle>;
}
interface BarSeriesNodeDataContext extends AbstractBarSeriesNodeDataContext<BarNodeDatum> {
    phantomNodeData: BarNodeDatum[];
    styles: SeriesNodeStyleContext<AgBarSeriesStyle>;
    segments?: Segment[];
}
type BarAnimationData = AbstractBarSeriesAnimationData<BarShape<BarNodeDatum>, BarNodeDatum>;
export declare class BarSeries extends AbstractBarSeries<BarShape<BarNodeDatum>, AgBarSeriesOptions, BarSeriesProperties, BarNodeDatum, BarNodeDatum, BarSeriesNodeDataContext> {
    static readonly className = "BarSeries";
    static readonly type: "bar";
    properties: BarSeriesProperties;
    connectsToYAxis: boolean;
    private readonly aggregationManager;
    get pickModeAxis(): "main" | undefined;
    protected phantomGroup: Group<unknown>;
    private phantomSelection;
    readonly phantomHighlightGroup: Group<unknown>;
    private phantomHighlightSelection;
    constructor(moduleCtx: ModuleContext);
    private crossFilteringEnabled;
    processData(dataController: DataController): Promise<void>;
    private yCumulativeKey;
    getSeriesDomain(direction: ChartAxisDirection): DomainWithMetadata<any>;
    getSeriesRange(direction: ChartAxisDirection, visibleRange: [any, any]): [number, number] | [];
    getZoomRangeFittingItems(xVisibleRange: [number, number], yVisibleRange: [number, number] | undefined, minVisibleItems: number): {
        x: [number, number];
        y: [number, number] | undefined;
    } | undefined;
    getVisibleItems(xVisibleRange: [number, number], yVisibleRange: [number, number] | undefined, minVisibleItems: number): number;
    private aggregateData;
    private estimateTargetRange;
    /**
     * Creates shared context for node datum creation/update operations.
     * This context is instantiated once and reused across all datum operations
     * to minimize memory allocations. Only caches values that are expensive to
     * compute - cheap property lookups use `this` directly.
     */
    private createNodeDatumContext;
    /**
     * Computes the x position for a datum at the given index.
     */
    private computeXPosition;
    private prepareNodeDatumState;
    /**
     * Creates a skeleton BarNodeDatum with minimal required fields.
     * The node will be populated by updateNodeDatum.
     */
    private createSkeletonNodeDatum;
    /**
     * Creates a BarNodeDatum (and optionally a phantom node) for a single data point.
     * Creates skeleton nodes and uses updateNodeDatum to populate them with calculated values.
     */
    private createNodeDatum;
    /**
     * Updates an existing BarNodeDatum in-place for value-only changes.
     * This is more efficient than recreating the entire node when only data values change
     * but the structure (insertions/removals) remains the same.
     */
    private updateNodeDatum;
    /**
     * Creates node data using aggregation filters for large datasets.
     */
    private createNodeDataWithAggregation;
    /**
     * Creates node data for grouped data processing.
     */
    private createNodeDataGrouped;
    /**
     * Creates node data for simple (non-grouped) data processing.
     */
    private createNodeDataSimple;
    /**
     * Handles node creation/update - reuses existing nodes when possible for incremental updates.
     * This method decides whether to update existing nodes in-place or create new ones.
     */
    private upsertNodeDatum;
    createNodeData(): {
        itemId: string;
        nodeData: BarNodeDatum[];
        phantomNodeData: BarNodeDatum[];
        labelData: BarNodeDatum[];
        scales: {
            x?: import("ag-charts-core").Scaling | undefined;
            y?: import("ag-charts-core").Scaling | undefined;
            angle?: import("ag-charts-core").Scaling | undefined;
            radius?: import("ag-charts-core").Scaling | undefined;
        };
        visible: boolean;
        groupScale: import("ag-charts-core").Scaling | undefined;
        styles: Record<HighlightState, Required<AgBarSeriesStyle>>;
        segments: {
            stroke?: string | undefined;
            strokeWidth?: number | undefined;
            strokeOpacity?: number | undefined;
            lineDash?: number[] | undefined;
            lineDashOffset?: number | undefined;
            fill?: import("ag-charts-types").AgColorType | undefined;
            fillOpacity?: number | undefined;
            clipRect: {
                x0: any;
                y0: any;
                x1: any;
                y1: any;
            };
        }[] | undefined;
    } | undefined;
    protected nodeFactory(): BarShape<any>;
    protected updateSeriesSelections(): void;
    protected updateHighlightSelectionItem(opts: {
        items?: BarNodeDatum[];
        highlightSelection: Selection<BarShape<BarNodeDatum>, BarNodeDatum>;
    }): Selection<BarShape<BarNodeDatum>, BarNodeDatum>;
    protected updateNodes(itemHighlighted: boolean, nodeRefresh: boolean): void;
    protected getHighlightData(nodeData: BarNodeDatum[], highlightedItem: BarNodeDatum): BarNodeDatum[] | undefined;
    protected updateDatumSelection(opts: {
        nodeData: BarNodeDatum[];
        datumSelection: Selection<BarShape, BarNodeDatum>;
    }): Selection<BarShape<any>, BarNodeDatum>;
    private makeStylerParams;
    private makeItemStylerParams;
    private getStyle;
    private getItemStyle;
    protected updateDatumStyles(opts: {
        datumSelection: Selection<BarShape, BarNodeDatum>;
        isHighlight: boolean;
    }): void;
    protected updateDatumNodes(opts: {
        datumSelection: Selection<BarShape, BarNodeDatum>;
        isHighlight: boolean;
        drawingMode: 'cutout' | 'overlay';
    }): void;
    protected updateLabelSelection(opts: {
        labelData: BarNodeDatum[];
        labelSelection: Selection<Text, BarNodeDatum>;
    }): Selection<Text<any>, BarNodeDatum>;
    protected updateLabelNodes(opts: {
        labelSelection: Selection<Text, BarNodeDatum>;
        isHighlight?: boolean;
    }): void;
    getTooltipContent(datumIndex: number): TooltipContent | undefined;
    private legendItemSymbol;
    getLegendData(legendType: ChartLegendType): CategoryLegendDatum[];
    protected resetDatumAnimation(data: CartesianAnimationData<BarShape<BarNodeDatum>, BarNodeDatum, BarNodeDatum, BarSeriesNodeDataContext>): void;
    animateReadyHighlight(data: Selection<BarShape<BarNodeDatum>, BarNodeDatum>): void;
    animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }: BarAnimationData): void;
    animateWaitingUpdateReady(data: BarAnimationData): void;
    private getDatumId;
    protected isLabelEnabled(): boolean;
    protected computeFocusBounds({ datumIndex }: PickFocusInputs): BBox | undefined;
    protected hasItemStylers(): boolean;
}
export {};
