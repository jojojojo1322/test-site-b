/**
 * Base interface for aggregation filters used by AggregationManager.
 */
export interface AggregationFilterBase {
    maxRange: number;
}
/**
 * Result type for partial aggregation with deferred computation.
 */
export interface PartialAggregationResult<TFilter> {
    immediate: TFilter[];
    computeRemaining?: () => TFilter[];
}
/**
 * Manages aggregation state and deferred computation for series.
 *
 * This class consolidates the common pattern used by Bar, OHLC, and RangeBar series
 * for managing multi-level aggregation with deferred computation of coarser levels.
 *
 * @example
 * ```typescript
 * private readonly aggregationManager = new AggregationManager<MyFilter>();
 *
 * private aggregateData(...) {
 *     return this.aggregationManager.aggregate({
 *         computePartial: () => computePartial(...),
 *         computeFull: () => computeFull(...),
 *         targetRange: this.estimateTargetRange(),
 *     });
 * }
 * ```
 */
export declare class AggregationManager<TFilter extends AggregationFilterBase> {
    private _filters;
    private readonly executor;
    get filters(): TFilter[] | undefined;
    /**
     * Perform aggregation with deferred computation of coarser levels.
     * Returns immediate filters suitable for current zoom level.
     *
     * @param options.computePartial - Function to compute partial aggregation (receives existing filters for reuse)
     * @param options.computeFull - Function to compute full aggregation (receives existing filters for reuse)
     * @param options.targetRange - Current pixel range for determining which level to compute immediately
     * @returns The computed filters (immediate level for partial, or all levels for full)
     */
    aggregate(options: {
        computePartial?: (existingFilters: TFilter[] | undefined) => PartialAggregationResult<TFilter> | undefined;
        computeFull: (existingFilters: TFilter[] | undefined) => TFilter[] | undefined;
        targetRange: number;
    }): TFilter[] | undefined;
    /**
     * Ensure we have an aggregation level suitable for the given range.
     * Forces deferred computation if needed.
     */
    ensureLevelForRange(range: number): void;
    /**
     * Get the best filter for a given range.
     */
    getFilterForRange(range: number): TFilter | undefined;
    /**
     * Cancel any pending deferred computation.
     */
    cancel(): void;
    /**
     * Mark all filters as stale (for invalidation on data refresh).
     */
    markStale(): void;
    private mergeFilters;
}
