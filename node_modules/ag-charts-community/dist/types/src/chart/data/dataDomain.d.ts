import { type BandLike, BandedStructure, type BandedStructureConfig } from './data-model/utils/bandedStructure';
export interface IDataDomain<D = any> {
    extend(val: any): void;
    getDomain(): D[];
}
type SortOrder = 1 | -1;
export declare class DiscreteDomain implements IDataDomain {
    private readonly domain;
    private readonly dateTimestamps;
    private hasDateValues;
    private sortedValues;
    private sortOrder;
    private isSortedUnique;
    static is(value: unknown): value is DiscreteDomain;
    /**
     * Configure domain for sorted unique mode.
     * When enabled, uses a single array for O(1) append.
     * Call this before extending with data.
     */
    setSortedUniqueMode(sortOrder: 1 | -1, isUnique: boolean): void;
    extend(val: any): void;
    getDomain(): unknown[];
    /** Returns true if this domain contains Date values stored as timestamps */
    isDateDomain(): boolean;
    /** Returns true if this domain is in sorted unique mode */
    isSortedUniqueMode(): boolean;
    /** Returns the sort order if in sorted mode, undefined otherwise */
    getSortOrder(): SortOrder | undefined;
    /** Merges another DiscreteDomain's values into this one */
    mergeFrom(other: DiscreteDomain): void;
    /** Converts from sorted array mode to Set mode (one-way transition) */
    private convertToSetMode;
}
export declare class ContinuousDomain<T extends number | Date> implements IDataDomain<T> {
    private domain;
    static is<T extends number | Date = any>(value: unknown): value is ContinuousDomain<T>;
    static extendDomain(values: unknown[], domain?: [number, number]): [number, number];
    extend(value: T): void;
    getDomain(): T[];
}
/**
 * Represents a single band within a BandedDomain.
 * Each band maintains its own sub-domain for a range of data indices.
 */
interface DomainBand<T> extends BandLike {
    /** The sub-domain for values in this band */
    subDomain: IDataDomain<T>;
}
/**
 * Configuration options for BandedDomain optimization.
 * Extends BandedStructureConfig for backward compatibility.
 */
export interface BandedDomainConfig extends BandedStructureConfig {
}
/**
 * A domain implementation that divides data into bands for efficient incremental updates.
 * Each band maintains its own sub-domain, allowing targeted updates without full rescans.
 *
 * Banding trades memory for performance. Each band maintains its own sub-domain,
 * so memory usage scales with targetBandCount Ã— number of properties.
 * For datasets < minDataSizeForBanding, banding is disabled to avoid overhead.
 */
export declare class BandedDomain<T = any> extends BandedStructure<DomainBand<T>> implements IDataDomain<T> {
    private readonly domainFactory;
    private fullDomainCache;
    private readonly isDiscrete;
    private sortOrder;
    private isUnique;
    constructor(domainFactory: () => IDataDomain<T>, config?: BandedDomainConfig, isDiscrete?: boolean);
    /**
     * Set sort order metadata from KEY_SORT_ORDERS.
     * When data is sorted and unique, enables fast array concatenation in getDomain().
     */
    setSortOrderMetadata(sortOrder: 1 | -1 | undefined, isUnique: boolean): void;
    /**
     * Creates a new domain band with its own sub-domain instance.
     * Configures sub-domain for sorted mode if applicable.
     */
    protected createBand(startIndex: number, endIndex: number): DomainBand<T>;
    /**
     * Initializes bands and clears the full domain cache.
     */
    initializeBands(dataSize: number): void;
    /**
     * Handles insertion and clears the full domain cache.
     */
    handleInsertion(insertIndex: number, insertCount: number): void;
    /**
     * Handles removal and clears the full domain cache.
     */
    handleRemoval(removeIndex: number, removeCount: number): void;
    /**
     * Split an oversized band into two smaller bands.
     * Override to handle band splitting for large datasets where banding is beneficial.
     */
    protected splitBand(bandIndex: number, idealSize: number): void;
    /**
     * Marks bands as dirty that need rescanning.
     */
    markBandsDirty(startIndex: number, endIndex: number): void;
    /**
     * Marks all bands as dirty, forcing a full rescan.
     */
    private markAllBandsDirty;
    /**
     * Extends the domain with values from specified bands.
     * This is called after dirty bands have been rescanned.
     */
    extendBandsFromData(data: T[], invalidData?: boolean[]): void;
    /**
     * Gets the bands that need rescanning.
     */
    getDirtyBands(): DomainBand<T>[];
    /**
     * Standard IDataDomain interface - extends domain with a single value.
     * Note: This is less efficient than batch operations with bands.
     */
    extend(_value: T): void;
    /**
     * Check if all sub-domains support fast sorted concatenation.
     */
    private canUseSortedConcatenation;
    /**
     * Concatenate sorted domains efficiently.
     * Only valid when canUseSortedConcatenation() returns true.
     */
    private concatenateSortedDomains;
    /**
     * Deduplicate nulls and Invalid Dates in a domain result array.
     * These represent invalid data and may appear from multiple bands.
     */
    private deduplicateNulls;
    /**
     * Combines all band sub-domains to get the overall domain.
     */
    getDomain(): T[];
    /**
     * Returns statistics about the banded domain for debugging.
     */
    getStats(): {
        bandCount: number;
        dirtyBandCount: number;
        averageBandSize: number;
        dataSize: number;
    };
}
export {};
