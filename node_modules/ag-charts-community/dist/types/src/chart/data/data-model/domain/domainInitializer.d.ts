import { BandedDomain, type IDataDomain } from '../../dataDomain';
import type { InternalDatumPropertyDefinition, SortOrderEntry } from '../../dataModelTypes';
import type { DataModelContext } from '../dataModelContext';
/**
 * Handles domain initialization and extension for the DataModel.
 * Manages both discrete and continuous domains, including banded domain optimization.
 */
export declare class DomainInitializer<K extends string> {
    private readonly ctx;
    constructor(ctx: DataModelContext<any, K>);
    /**
     * Sets up the appropriate domain type for a property definition.
     * Returns a BandedDomain wrapping DiscreteDomain for category values,
     * or a BandedDomain wrapping ContinuousDomain for continuous values.
     * Falls back to non-banded domains when banding is disabled.
     *
     * @param sortOrderEntry Optional sort order metadata from KEY_SORT_ORDERS.
     * When data is sorted and unique, enables fast array concatenation optimization.
     */
    setupDomainForDefinition(def: InternalDatumPropertyDefinition<K>, bandedDomains: Map<InternalDatumPropertyDefinition<any>, BandedDomain>, sortOrderEntry?: SortOrderEntry): IDataDomain;
    /**
     * Extends a domain from data array, using banded optimization if available.
     * Note: For BandedDomain, bands should already be initialized before calling this method.
     */
    extendDomainFromData(domain: IDataDomain, data: any[], invalidData?: boolean[]): void;
    /**
     * Initializes a banded domain if needed based on data size and state.
     * This is a memory optimization that divides large datasets into bands.
     */
    initializeBandedDomain(domain: IDataDomain, dataSize: number, propertyName?: string): void;
}
