/**
 * Minimal interface for band-like structures.
 * Both domain bands and reducer bands must have these properties.
 */
export interface BandLike {
    startIndex: number;
    endIndex: number;
    isDirty: boolean;
}
/**
 * Configuration for band initialization.
 */
export interface BandConfig {
    enableBanding: boolean;
    minDataSizeForBanding: number;
    targetBandCount: number;
}
/**
 * Configuration options for banded structures.
 * This is the base config used by BandedStructure and extended by BandedDomainConfig.
 */
export interface BandedStructureConfig {
    /** Minimum data size to activate banding (default: 1000) */
    minDataSizeForBanding?: number;
    /** Target number of bands to create (default: 10) */
    targetBandCount?: number;
    /** Maximum items per band before splitting (default: undefined - no limit) */
    maxBandSize?: number;
    /** Enable banding optimization (default: true) */
    enableBanding?: boolean;
}
/**
 * Shared index map type for splice/update operations applied to banded structures.
 */
export interface BandIndexMap {
    spliceOps: Array<{
        index: number;
        insertCount: number;
        deleteCount: number;
    }>;
    updatedIndices: Set<number>;
}
/**
 * Adjusts band indices for an insertion operation.
 * Handles three cases:
 * 1. Insertion before band - shift both boundaries
 * 2. Insertion within band or at end of last band - extend end boundary
 * 3. Insertion after band - no changes
 *
 * @param band The band to adjust
 * @param insertIndex Index where insertion occurs
 * @param insertCount Number of items inserted
 * @param isLastBand Whether this is the last band in the array
 * @returns true if band was modified and should be marked dirty
 */
export declare function adjustBandForInsertion<T extends BandLike>(band: T, insertIndex: number, insertCount: number, isLastBand: boolean): boolean;
/**
 * Adjusts band indices for a removal operation.
 * Handles multiple overlap cases:
 * 1. Removal before band - shift both boundaries
 * 2. Removal fully contains band - collapse to empty
 * 3. Removal overlaps start of band - shrink from start
 * 4. Removal overlaps end of band - shrink from end
 * 5. Removal within band - shrink end boundary
 *
 * @param band The band to adjust
 * @param removeIndex Index where removal starts
 * @param removeCount Number of items removed
 * @returns true if band was affected and should be marked dirty
 */
export declare function adjustBandForRemoval<T extends BandLike>(band: T, removeIndex: number, removeCount: number): boolean;
/**
 * Calculates target band count based on data size.
 * Uses 1000 items per band as a baseline, with a configurable minimum.
 *
 * @param dataSize Total number of data items
 * @param minBandCount Minimum number of bands to create
 * @returns Target number of bands
 */
export declare function calculateTargetBandCount(dataSize: number, minBandCount: number): number;
/**
 * Calculates ideal band size given data size and target band count.
 *
 * @param dataSize Total number of data items
 * @param targetBandCount Target number of bands
 * @returns Ideal size for each band
 */
export declare function calculateIdealBandSize(dataSize: number, targetBandCount: number): number;
/**
 * Filters out empty bands (where endIndex <= startIndex).
 * Empty bands can occur after removals that eliminate all data in a band.
 */
export declare function filterEmptyBands<T extends BandLike>(bands: T[]): T[];
/**
 * Creates an array of bands with the given configuration.
 * For small datasets or when banding is disabled, creates a single band.
 * Otherwise, divides data into approximately equal-sized bands.
 */
export declare function initializeBandArray<T extends BandLike>(dataSize: number, config: BandConfig, bandFactory: (startIndex: number, endIndex: number) => T): T[];
/**
 * Marks bands containing the given index as dirty.
 * Used for update operations where data changes but dataset size doesn't.
 */
export declare function markBandDirtyAtIndex<T extends BandLike>(bands: T[], index: number): void;
/**
 * Apply splice operations (insertions and deletions) to a band-like structure.
 * This is a generic helper for any structure with handleInsertion/handleRemoval methods.
 */
export declare function applySpliceOperations(bandHandler: {
    handleInsertion(index: number, count: number): void;
    handleRemoval(index: number, count: number): void;
}, spliceOps: Array<{
    index: number;
    insertCount: number;
    deleteCount: number;
}>): void;
/**
 * Mark bands dirty at updated indices by using handleInsertion with 0 count.
 * This avoids changing band structure while marking them for recalculation.
 */
export declare function markUpdatedIndices(bandHandler: {
    handleInsertion(index: number, count: number): void;
}, updatedIndices: Set<number>): void;
/**
 * Applies a change description (insertions, deletions, updates) to a band-like structure.
 * Combines splice operations and updated-index handling to keep band dirty-state logic consistent.
 */
export declare function applyIndexMapToBandHandler(bandHandler: {
    handleInsertion(index: number, count: number): void;
    handleRemoval(index: number, count: number): void;
}, indexMap: BandIndexMap): void;
/**
 * Abstract base class for band-based data structures.
 * Provides common functionality for dividing data into bands for efficient incremental updates.
 *
 * Both BandedReducer and BandedDomain share the same banding logic:
 * - Initialize bands based on data size
 * - Handle insertions with proactive splitting
 * - Handle removals with band cleanup
 * - Track dirty state for incremental processing
 *
 * Subclasses differ only in what they store per band:
 * - BandedReducer: stores cachedResult for aggregations
 * - BandedDomain: stores subDomain for domain calculations
 */
export declare abstract class BandedStructure<TBand extends BandLike> {
    protected bands: TBand[];
    protected dataSize: number;
    protected readonly config: Required<BandedStructureConfig>;
    constructor(config?: BandedStructureConfig);
    applyIndexMap(indexMap: BandIndexMap): void;
    /**
     * Abstract method to create a band with subclass-specific data.
     * @param startIndex Starting index of the band
     * @param endIndex Ending index of the band
     * @returns A new band instance
     */
    protected abstract createBand(startIndex: number, endIndex: number): TBand;
    /**
     * Initializes or rebalances bands based on current data size.
     */
    initializeBands(dataSize: number): void;
    /**
     * Returns the number of bands currently in this structure.
     * Useful for checking if bands need initialization.
     */
    getBandCount(): number;
    /**
     * Handles insertion of new data by adjusting band indices.
     * Uses proactive band splitting to maintain optimal band sizes.
     */
    handleInsertion(insertIndex: number, insertCount: number): void;
    /**
     * Handles removal of data by adjusting band indices.
     * Uses shared utilities for consistent band manipulation.
     */
    handleRemoval(removeIndex: number, removeCount: number): void;
    /**
     * Split an oversized band into two smaller bands.
     * Called when a band exceeds maxBandSize during insertion.
     *
     * Strategy:
     * - Split the band as evenly as possible
     * - Both halves marked as dirty (need recalculation)
     * - No cache preservation (splitting indicates data changed)
     */
    protected splitBand(bandIndex: number, idealSize: number): void;
    /**
     * Returns statistics about the banded structure for debugging.
     * Subclasses can override to add domain-specific stats.
     */
    getStats(): Record<string, number>;
    markRangeDirty(startIndex: number, endIndex: number): void;
}
