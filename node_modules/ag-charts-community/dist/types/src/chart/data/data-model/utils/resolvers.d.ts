import type { GroupedData, ProcessedData, ProcessedDataDef, PropertyDefinition, ScopeProvider, SortOrderEntry, UngroupedData } from '../../dataModelTypes';
import { type SortOrder } from '../../sortOrder';
import type { DataModelContext } from '../dataModelContext';
/**
 * DataModelResolvers handles lookups and resolution of processed data.
 *
 * RESOLVER RESPONSIBILITIES:
 * - Resolves property definitions by ID within a scope
 * - Looks up keys, columns, and values from processed data
 * - Manages domain and sort order resolution
 * - Provides range lookups for data access
 *
 * SCOPE-AWARE RESOLUTION:
 * - All lookups are scoped to specific data sources
 * - Uses internal scope cache for fast property definition lookup
 * - Throws clear errors when definitions are not found
 */
export declare class DataModelResolvers<D extends object, K extends keyof D & string> {
    private readonly ctx;
    private readonly rangeBetweenBuffer;
    constructor(ctx: DataModelContext<D, K>);
    resolveMissingDataCount(scope: ScopeProvider): number;
    resolveProcessedDataDefById(scope: ScopeProvider, searchId: string): ProcessedDataDef | never;
    resolveProcessedDataIndexById(scope: ScopeProvider, searchId: string): number;
    resolveKeysById<T = string>(scope: ScopeProvider, searchId: string, processedData: UngroupedData<any> | GroupedData<any>): T[];
    hasColumnById(scope: ScopeProvider, searchId: string): boolean;
    resolveColumnById<T = any>(scope: ScopeProvider, searchId: string, processedData: UngroupedData<any> | GroupedData<any>): T[];
    resolveColumnNeedsValueOf(scope: ScopeProvider, searchId: string, processedData: UngroupedData<any> | GroupedData<any>): boolean;
    /**
     * Converts a relative datum index to an absolute column index.
     *
     * INDEXING STRATEGY:
     * - Relative index: Offset from the start of a group (stored in datumIndices)
     * - Absolute index: Position in the full column array
     * - Conversion: absoluteIndex = groupIndex + relativeIndex
     *
     * When groupsUnique=true, relativeIndex is always 0, making this a simple
     * identity mapping. This optimization reduces memory usage significantly
     * for large datasets with unique keys.
     *
     * @param groupIndex index of the group in ProcessedData.groups
     * @param relativeDatumIndex relative index stored in group.datumIndices
     * @returns absolute index for accessing columns
     */
    resolveAbsoluteIndex(groupIndex: number, relativeDatumIndex: number): number;
    getDomain(scope: ScopeProvider, searchId: string, type: PropertyDefinition<any>['type'], processedData: ProcessedData<K>): any[] | [number, number] | [];
    getDomainBetweenRange(scope: ScopeProvider, searchIds: string[], [i0, i1]: [number, number], processedData: ProcessedData<K>): [number, number];
    private getSortOrder;
    getKeySortOrder(scope: ScopeProvider, searchId: string, processedData: ProcessedData<K>): SortOrder;
    getKeySortEntry(scope: ScopeProvider, searchId: string, processedData: ProcessedData<K>): SortOrderEntry | undefined;
    getColumnSortOrder(scope: ScopeProvider, searchId: string, processedData: ProcessedData<K>): SortOrder;
    private getDomainsByType;
}
