import type { BandedDomainConfig } from '../../dataDomain';
import { type BandLike, BandedStructure } from '../utils/bandedStructure';
export interface ReducerBand extends BandLike {
    cachedResult: unknown;
}
export interface ReducerContext {
    rawData: unknown[];
    keyColumns: unknown[][];
    keysParam: unknown[];
}
/**
 * Minimal reducer definition interface for BandedReducer.
 * This avoids circular dependency with dataModelTypes.ts.
 */
export interface ReducerDefinition<T = any> {
    initialValue?: T;
    reducer: () => (acc: T, keys: unknown[]) => T;
    needsOverlap?: boolean;
    combineResults?: (bandResults: T[]) => T;
}
/**
 * Band-based structure for reducer aggregations.
 * Each band maintains a cached result for efficient incremental updates.
 *
 * This class extends BandedStructure with reducer-specific functionality:
 * - Caching aggregation results per band
 * - Evaluating reducers across bands with overlap support
 * - Combining band results into final aggregated values
 * - Tracking scan ratios for performance metrics
 *
 * Symmetrical to BandedDomain which handles domain aggregation.
 */
export declare class BandedReducer extends BandedStructure<ReducerBand> {
    private lastDirtyBandCount;
    private lastScanRatio;
    private statsCaptured;
    constructor(config?: BandedDomainConfig);
    /**
     * Creates a new reducer band with undefined cached result.
     */
    protected createBand(startIndex: number, endIndex: number): ReducerBand;
    /**
     * Initializes bands and resets stats capture flag.
     */
    initializeBands(dataSize: number): void;
    /**
     * Gets the array of bands for direct access.
     * For production code, prefer using evaluateFromData() and getResult() for symmetry with BandedDomain.
     * This method is primarily for testing and debugging band structure.
     */
    getBands(): ReducerBand[];
    /**
     * Evaluates a reducer across all bands, reusing cached results for clean bands.
     * Symmetrical to BandedDomain.extendBandsFromData().
     *
     * @param def Reducer definition with reducer function, initial value, and overlap settings
     * @param context Reducer context containing raw data and key columns
     * @param reuseCleanBands Whether to reuse cached results for clean bands (default: false)
     */
    evaluateFromData(def: ReducerDefinition, context: ReducerContext, reuseCleanBands?: boolean): void;
    /**
     * Combines all band results to get the final aggregated value.
     * Symmetrical to BandedDomain.getDomain().
     *
     * @param def Reducer definition with combineResults function
     * @returns Combined result from all bands
     */
    getResult(def: ReducerDefinition): unknown;
    /**
     * Evaluates a reducer over a specific range of data indices.
     * Symmetrical to BandedDomain's band scanning loop in extendBandsFromData().
     *
     * @param def Reducer definition with initial value
     * @param reducer Reducer function to apply
     * @param context Reducer context with data and keys
     * @param startIndex Starting index (inclusive)
     * @param endIndex Ending index (exclusive)
     * @returns Accumulated reducer result for the range
     */
    private evaluateRange;
    /**
     * Capture the current dirty state before processing.
     * Call this before marking bands as clean to preserve stats for reporting.
     */
    captureStatsBeforeProcessing(): void;
    /**
     * Returns reducer-specific statistics including cache hits and scan ratio.
     */
    getStats(): {
        totalBands: number;
        dirtyBands: number;
        dataSize: number;
        scanRatio: number;
        cacheHits: number;
    };
}
