import { type IDataDomain } from '../../dataDomain';
import { type InternalDatumPropertyDefinition, type ProcessedData, type ProcessedValue } from '../../dataModelTypes';
import type { DataModelContext } from '../dataModelContext';
import type { ScopeCacheManager } from '../utils/scopeCache';
import { DomainInitializer } from './domainInitializer';
import { type SpecializedProcessValueFn } from './processValueFactory';
/**
 * Manages domain computation and processing for the DataModel.
 * Handles both discrete and continuous domains, including banded domain optimization
 * and value processing during data transformation.
 */
export declare class DomainManager<D extends object, K extends keyof D & string> {
    private readonly ctx;
    private readonly initializer;
    private readonly scopeCacheManager;
    private readonly processValueFactory;
    constructor(ctx: DataModelContext<D, K>, initializer: DomainInitializer<K>, scopeCacheManager: ScopeCacheManager<K>);
    /**
     * Recomputes all domains from processed data.
     * Uses BandedDomain optimization for continuous domains to avoid full rescans.
     * Shares domains between keys and values when they reference the same property.
     */
    recomputeDomains(processedData: ProcessedData<D>): void;
    /**
     * Creates domain instances for the given definitions, reusing banded domains when available.
     * For key definitions, passes KEY_SORT_ORDERS metadata to enable fast array concatenation.
     */
    private setupDefinitionDomains;
    /**
     * Initializes banded domains for each definition using the provided data length accessor.
     */
    private initializeDomainBands;
    /**
     * Extends domains from data sources using a shared traversal.
     * @param skipDomains Optional set of domains to skip (already extended via shared key processing)
     */
    private extendDomainsFromData;
    /**
     * Sets up value domains, reusing key domains where properties match.
     * This avoids duplicate domain computation for properties that appear as both key and value.
     */
    private setupValueDomainsWithSharing;
    /**
     * Initializes domain processor for value processing during data transformation.
     * Returns domain maps and processing functions used during data extraction.
     * Uses specialized functions per property definition to eliminate branching in hot paths.
     * Shares domains between keys and values when they reference the same property.
     */
    initDataDomainProcessor(domainMode: 'extend' | 'skip'): {
        dataDomain: Map<object, IDataDomain<any>>;
        processValue: (def: InternalDatumPropertyDefinition<K>, datum: unknown, idx: number, valueScopes: string | string[]) => ProcessedValue;
        getProcessValue: (def: InternalDatumPropertyDefinition<K>) => SpecializedProcessValueFn;
        initDataDomain: () => void;
        scopes: Set<string>;
        allScopesHaveSameDefs: boolean;
    };
    /**
     * Collects metadata about banded domain optimization for debugging and testing.
     * Stores statistics about domain banding per key and value definition.
     */
    private collectDomainBandingMetadata;
}
