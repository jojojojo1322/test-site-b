import type { Point } from 'ag-charts-core';
import type { AgMarkerShape } from 'ag-charts-types';
import { BBox } from '../../scene/bbox';
import { type NodeOptions } from '../../scene/node';
import { Path } from '../../scene/shape/path';
import type { CanvasContext } from '../../scene/shape/shape';
declare class InternalMarker<D = any> extends Path<D> {
    shape: AgMarkerShape;
    __shape: AgMarkerShape;
    x: number;
    __x: number;
    y: number;
    __y: number;
    size: number;
    __size: number;
    isPointInPath(x: number, y: number): boolean;
    get midPoint(): {
        x: number;
        y: number;
    };
    distanceSquared(x: number, y: number): number;
    updatePath(): void;
    protected computeBBox(): BBox;
    protected executeFill(ctx: CanvasContext, path?: Path2D): void;
    protected executeStroke(ctx: CanvasContext, path?: Path2D): void;
}
declare const Marker_base: new (...args: any[]) => import("../../scene/transformable").RotatableType<import("../../scene/transformable").ScalableType<import("../../scene/transformable").TranslatableType<InternalMarker<any>>>>;
export declare class Marker extends Marker_base {
    static anchor(shape: AgMarkerShape | undefined): Point;
    constructor(options?: NodeOptions & {
        shape?: AgMarkerShape;
    });
    /**
     * Optimised reset for animation hot paths.
     * Bypasses SceneChangeDetection decorators by writing directly to backing fields.
     *
     * This avoids per-property overhead from:
     * - Equality checks (comparing old vs new values)
     * - Change callbacks (triggering downstream updates)
     * - Object.keys() iteration
     *
     * A single markDirty() call at the end ensures the scene graph is properly invalidated.
     * WARNING: Only use for animation hot paths where performance is critical.
     */
    resetAnimationProperties(x: number, y: number, size: number, opacity: number, scalingX: number, scalingY: number): void;
}
export {};
