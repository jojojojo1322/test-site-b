import type { DomainWithMetadata, NormalizedDomain, ScaleTickParams, ScaleTickResult } from 'ag-charts-core';
import { ScaleAlignment } from 'ag-charts-core';
import type { AgTimeInterval, AgTimeIntervalUnit } from 'ag-charts-types';
import { DiscreteTimeScale, type UniformityCheck } from './discreteTimeScale';
export declare class UnitTimeScale extends DiscreteTimeScale {
    static is(value: unknown): value is UnitTimeScale;
    readonly type = "unit-time";
    readonly defaultTickCount = 12;
    static supportsInterval(domain: Date[], interval: AgTimeInterval | AgTimeIntervalUnit): boolean;
    private _domain;
    private _uniformityCache;
    private _domainBoundaries;
    private _bandRangeCache;
    /** Encoded band values (internal encoding, not timestamps) */
    private _encodedBands;
    /** Encoding params needed to decode encoded bands to Date/timestamp */
    private _encodingParams;
    /** Cached linear params for O(1) findIndex */
    private _linearParams;
    set domain(domain: Date[]);
    get domain(): Date[];
    private _interval;
    get interval(): AgTimeInterval | AgTimeIntervalUnit | undefined;
    set interval(interval: AgTimeInterval | AgTimeIntervalUnit | undefined);
    private _bands;
    get bands(): readonly Date[];
    private _numericBands;
    protected get numericBands(): number[];
    /**
     * Ensure encoded bands are computed. This is the numeric-first optimization:
     * we compute just the encoded values (cheap numbers) and defer Date creation.
     */
    private ensureEncodedBands;
    /** Override to return band count without triggering Date materialization */
    getBandCountForUpdate(): number;
    getUniformityCache(visibleRange?: [number, number]): UniformityCheck | undefined;
    normalizeDomains(...domains: DomainWithMetadata<Date>[]): NormalizedDomain<Date>;
    private getCachedBandRange;
    private getDomainBoundaries;
    /** Get linear params for O(1) index calculation and scaling metadata */
    getLinearParams(): {
        firstBandTime: number;
        intervalMs: number;
    } | undefined;
    /** Check if current encoding uses a linear unit (exact arithmetic, no DST issues) */
    private isLinearUnit;
    /**
     * O(1) findIndex for uniform bands.
     * For linear units (ms/sec/min/hour), uses pure arithmetic without verification.
     * For non-linear units (day/month/year), verifies against actual band values.
     */
    findIndex(value: Date, alignment?: ScaleAlignment): number | undefined;
    /**
     * Optimized convert for UnitTimeScale with O(1) boundary checks.
     * Uses linear params for fast bounds checking while delegating actual
     * conversion to parent for accuracy in edge cases.
     */
    convert(value: Date, options?: {
        clamp?: boolean;
        alignment?: ScaleAlignment;
    }): number;
    private calculateBands;
    ticks({ interval }: ScaleTickParams<AgTimeInterval | AgTimeIntervalUnit | number>, domain?: Date[], visibleRange?: [number, number], { extend }?: {
        extend?: boolean | undefined;
    }): ScaleTickResult<Date> | undefined;
}
